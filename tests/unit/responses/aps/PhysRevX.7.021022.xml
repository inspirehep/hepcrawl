<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD with OASIS Tables with MathML3 v1.1d1 20130915//EN" "JATS-journalpublishing-oasis-article1-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:oasis="http://www.niso.org/standards/z39-96/ns/oasis-exchange/table" article-type="research-article">
  <front>
    <journal-meta>
      <journal-id journal-id-type="publisher-id">PRX</journal-id>
      <journal-id journal-id-type="coden">PRXHAE</journal-id>
      <journal-title-group>
        <journal-title>Physical Review X</journal-title>
        <abbrev-journal-title>Phys. Rev. X</abbrev-journal-title>
      </journal-title-group>
      <issn pub-type="epub">2160-3308</issn>
      <publisher>
        <publisher-name>American Physical Society</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="doi">10.1103/PhysRevX.7.021022</article-id>
      <article-categories>
        <subj-group subj-group-type="toc-major">
          <subject>RESEARCH ARTICLES</subject>
        </subj-group>
        <subj-group subj-group-type="subject-areas">
          <compound-subject>
            <compound-subject-part content-type="code">quantum</compound-subject-part>
            <compound-subject-part content-type="subject">Quantum Physics</compound-subject-part>
          </compound-subject>
          <compound-subject>
            <compound-subject-part content-type="code">quantum-info</compound-subject-part>
            <compound-subject-part content-type="subject">Quantum Information</compound-subject-part>
          </compound-subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Code Properties from Holographic Geometries</article-title>
        <alt-title alt-title-type="running-title">CODE PROPERTIES FROM HOLOGRAPHIC GEOMETRIES</alt-title>
        <alt-title alt-title-type="running-author">FERNANDO PASTAWSKI AND JOHN PRESKILL</alt-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Pastawski</surname>
            <given-names>Fernando</given-names>
          </name>
          <xref ref-type="aff" rid="a1"/>
        </contrib>
        <aff id="a1">Dahlem Center for Complex Quantum Systems, <institution>Freie Universität Berlin</institution>, 14195 Berlin, Germany</aff>
      </contrib-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Preskill</surname>
            <given-names>John</given-names>
          </name>
          <xref ref-type="aff" rid="a2"/>
        </contrib>
        <aff id="a2"><institution>Institute for Quantum Information and Matter</institution>, California Institute of Technology, Pasadena, California 91125, USA</aff>
      </contrib-group>
      <pub-date iso-8601-date="2017-05-15" pub-type="epub">
        <day>15</day>
        <month>May</month>
        <year>2017</year>
      </pub-date>
      <pub-date iso-8601-date="2017-04-01" pub-type="ppub">
        <day>1</day>
        <month>April</month>
        <year>2017</year>
      </pub-date>
      <volume>7</volume>
      <issue>2</issue>
      <elocation-id>021022</elocation-id>
      <history>
        <date iso-8601-date="2017-01-05" date-type="received">
          <day>5</day>
          <month>January</month>
          <year>2017</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>Published by the American Physical Society</copyright-statement>
        <copyright-year>2017</copyright-year>
        <copyright-holder>authors</copyright-holder>
        <license license-type="creative-commons" xlink:href="https://creativecommons.org/licenses/by/4.0/">
          <license-p content-type="usage-statement">Published by the American Physical Society under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International</ext-link> license. Further distribution of this work must maintain attribution to the author(s) and the published article’s title, journal citation, and DOI.</license-p>
        </license>
      </permissions>
      <abstract>
        <p>Almheiri, Dong, and Harlow [<mixed-citation publication-type="journal"><source>J. High Energy Phys.</source><issue>04</issue> (<volume>2015</volume>) <page-range>163</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP04(2015)163</pub-id></mixed-citation>] proposed a highly illuminating connection between the <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> holographic correspondence and operator algebra quantum error correction (OAQEC). Here, we explore this connection further. We derive some general results about OAQEC, as well as results that apply specifically to quantum codes that admit a holographic interpretation. We introduce a new quantity called price, which characterizes the support of a protected logical system, and find constraints on the price and the distance for logical subalgebras of quantum codes. We show that holographic codes defined on bulk manifolds with asymptotically negative curvature exhibit uberholography, meaning that a bulk logical algebra can be supported on a boundary region with a fractal structure. We argue that, for holographic codes defined on bulk manifolds with asymptotically flat or positive curvature, the boundary physics must be highly nonlocal, an observation with potential implications for black holes and for quantum gravity in AdS space at distance scales that are small compared to the AdS curvature radius.</p>
      </abstract>
      <abstract abstract-type="summary">
        <p>A deep link might exist between two seemingly disparate but far-reaching ideas in physics: quantum error correction and the holographic principle. Quantum error correction concerns using redundant encoding to protect quantum information from damage, and it has been studied extensively because of its relevance to reliable operation of noisy quantum computers. The holographic principle, meanwhile, states that all information about a volume of space can be encoded on the surface area of that volume, much as a hologram encodes a 3D image on a 2D surface. Recent research suggests that how our physical space is structured may also correspond to redundantly represented information. We further explore this connection between redundant information and geometry.</p>
        <p>Specifically, we look at connections between quantum error-correcting codes and the “holographic correspondence,” which asserts that a suitably chosen quantum theory, without gravity, can be precisely equivalent to a theory of quantum gravity in a negatively curved spacetime. We analyze the properties of holographic quantum codes, quantum error-correcting codes that capture the essential features of the holographic correspondence. These codes provide an information-theoretic interpretation for physical notions such as points in space, black holes, and spacetime curvature.</p>
        <p>Our work provides a new paradigm for designing quantum error-correction schemes and secret sharing codes, from which we expect many new constructions, and it also clarifies the information-theoretic foundations of the holographic correspondence.</p>
      </abstract>
      <funding-group>
        <award-group award-type="unspecified">
          <funding-source>
            <named-content content-type="name">National Science Foundation</named-content>
            <named-content content-type="fundref:id">http://dx.doi.org/10.13039/100000001</named-content>
            <named-content content-type="fundref:alternate-name">NSF</named-content>
            <named-content content-type="country">http://sws.geonames.org/6252001/</named-content>
            <named-content content-type="aps-code">NSF</named-content>
          </funding-source>
          <award-id>NSF PHY-1125915NSF PHY-1125915</award-id>
        </award-group>
        <award-group award-type="unspecified">
          <funding-source>
            <named-content content-type="name">Gordon and Betty Moore Foundation</named-content>
            <named-content content-type="fundref:id">http://dx.doi.org/10.13039/100000936</named-content>
            <named-content content-type="fundref:alternate-name">Gordon E. and Betty I. Moore Foundation</named-content>
            <named-content content-type="country">http://sws.geonames.org/6252001/</named-content>
          </funding-source>
        </award-group>
        <award-group award-type="unspecified">
          <funding-source>
            <named-content content-type="name">Simons Foundation</named-content>
            <named-content content-type="fundref:id">http://dx.doi.org/10.13039/100000893</named-content>
            <named-content content-type="country">http://sws.geonames.org/6252001/</named-content>
          </funding-source>
        </award-group>
        <award-group award-type="unspecified">
          <funding-source>
            <named-content content-type="name">H2020 European Research Council</named-content>
            <named-content content-type="fundref:id">http://dx.doi.org/10.13039/100010663</named-content>
            <named-content content-type="fundref:alternate-name">H2020 Excellent Science - European Research Council</named-content>
            <named-content content-type="fundref:alternate-name">European Research Council</named-content>
            <named-content content-type="fundref:alternate-name">ERC</named-content>
            <named-content content-type="country">http://sws.geonames.org/2802361/</named-content>
          </funding-source>
        </award-group>
      </funding-group>
      <counts>
        <page-count count="20"/>
      </counts>
    </article-meta>
  </front>
  <body>
    <sec id="s1">
      <label>I.</label>
      <title>INTRODUCTION</title>
      <p>Quantum error correction and the holographic principle are two of the most far-reaching ideas in contemporary physics. Quantum error correction provides a basis for believing that scalable quantum computers can be built and operated in the foreseeable future. The <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> holographic correspondence is currently our best tool for understanding nonperturbative quantum gravity. In a remarkable paper <xref ref-type="bibr" rid="c1">[1]</xref>, Almheiri, Dong, and Harlow suggested that these two deep ideas are closely related.</p>
      <p>The <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> correspondence is an exact duality between two quantum theories—quantum gravity in (<inline-formula><mml:math display="inline"><mml:mrow><mml:mi>D</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>)-dimensional anti–de Sitter space and a conformally invariant quantum field theory (without gravity) defined on its <inline-formula><mml:math display="inline"><mml:mi>D</mml:mi></mml:math></inline-formula>-dimensional boundary. The observables of the two theories are related by a complex dictionary, which maps local operators supported deep inside the bulk spacetime to highly nonlocal operators acting on the boundary CFT. Almheiri <italic>et al.</italic> proposed interpreting this dictionary as the encoding map of a quantum error-correcting code, where the code subspace is the low-energy sector of the CFT. Bulk local operators are regarded as “logical” operators that map the code subspace <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to itself, and they are well protected against erasure of portions of the boundary. The holographic dictionary is an encoding map that embeds the logical system inside the physical Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> of the CFT. This proposal provides a rich and enticing new perspective on the relationship between the emergent bulk geometry and the entanglement structure of the CFT.</p>
      <p>To model holography faithfully, the quantum error-correcting code must have special properties that invite a geometrical interpretation. Code constructions that realize the ideas in Ref. <xref ref-type="bibr" rid="c1">[1]</xref>, based on tensor networks that cover the associated bulk geometry, were constructed in Ref. <xref ref-type="bibr" rid="c2">[2]</xref> and extended in Ref. <xref ref-type="bibr" rid="c3">[3]</xref>. Importantly, it was shown <xref ref-type="bibr" rid="c3">[3]</xref> that codes can have holographic properties even when the underlying bulk geometry does not have negative curvature; this insight may broaden our perspective on how AdS space is special.</p>
      <p>Our goal in this paper is to develop these ideas further. Our motivation is twofold. On one hand, holographic codes have opened a new avenue in quantum coding theory, and it is worthwhile to explore more deeply how geometric insights can provide new methods for deriving code properties. On the other hand, holographic codes provide a useful tool for sharpening the connections between holographic duality and quantum information theory. Specifically, as emphasized in Ref. <xref ref-type="bibr" rid="c1">[1]</xref>, holographic codes are best described and analyzed using the language of operator algebra quantum error correction <xref ref-type="bibr" rid="c4 c5 c6 c7">[4–7]</xref>. This powerful framework deserves to be better known, and much of this paper is devoted to amplifying and applying it.</p>
      <p>We view our work here as a step along the road toward answering a fundamental question about quantum gravity and holography: What is the bulk? The <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> correspondence has bestowed many blessings but should be regarded as a crutch that must eventually be discarded to clear the way for future progress in quantum cosmology. We think that strengthening the ties between geometric and algebraic properties will be empowering and that operator algebra quantum error correction can help us reach this goal. As examples, we provide an algebraic characterization of a point in the bulk spacetime and discuss criteria for local correctability of the boundary theory. We also elaborate on the notion of uberholography, in which bulk physics can be reconstructed on a boundary subsystem with fractal geometry.</p>
      <sec id="s1a">
        <label>A.</label>
        <title>Outline</title>
        <p>In Sec. <xref ref-type="sec" rid="s2">II</xref>, we review the formalism of operator algebra quantum error correction (OAQEC). We explain how the notion of code distance can be applied to a subalgebra of a quantum code’s logical algebra, and we introduce the complementary notion of the price of a logical subalgebra, the size of the minimal subsystem of the physical Hilbert space which supports the logical subalgebra. We also derive some inequalities relating distance and price, and note that distance and price are equal for the logical subalgebra supported on a bulk point. In Sec. <xref ref-type="sec" rid="s3">III</xref>, we review the connection between holography and quantum error correction, emphasizing the role of OAQEC in the analysis of holographic codes. We formulate the entanglement wedge hypothesis, a geometric criterion that determines whether a bulk logical subalgebra can be reconstructed on a specified boundary region, and work out some of its implications. We also discuss properties of punctures in the bulk geometry, which provide a crude description of black holes inside the bulk.</p>
        <p>In Sec. <xref ref-type="sec" rid="s4">IV</xref>, we explain the idea of uberholography and compute the universal fractal dimension, which determines how price and distance scale with system size for a holographic code defined on a hyperbolic disk. In Sec. <xref ref-type="sec" rid="s5">V</xref>, we investigate the conditions for local correctability in a holographic code, where by “local” we mean that the erasure of a small connected boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> can be corrected by a recovery map that acts only in a slightly larger region containing <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. We explain that holographic codes are locally correctable when the bulk geometry is negatively curved asymptotically but not for asymptotic flat or positive curvature. We interpret this property as a signal of nonlocal physics on the boundary in the flat and positively curved cases, and we also relate properties of black holes to features of holographic codes with positive curvature. In Sec. <xref ref-type="sec" rid="s6">VI</xref>, we use geometrical and entropic arguments to prove a strong quantum Singleton bound for holographic codes, which constrains the price and distance of a logical subalgebra. Section <xref ref-type="sec" rid="s7">VII</xref> contains some concluding comments.</p>
      </sec>
    </sec>
    <sec id="s2">
      <label>II.</label>
      <title>OPERATOR ALGEBRA QUANTUM ERROR CORRECTION</title>
      <p>In this section, we briefly review the principles of OAQEC <xref ref-type="bibr" rid="c4 c5 c6 c7">[4–7]</xref>, providing a foundation for the discussion of holographic codes. We explain how the notion of code distance can be generalized to the OAQEC setting. We also introduce a related but complementary notion, the price of a code and of a logical operator algebra. In a holographic context, the distance of a bulk logical algebra characterizes how well the bulk degrees of freedom are protected against erasure of portions of the boundary, while its price characterizes the minimal boundary region on which the bulk degrees of freedom can be reconstructed.</p>
      <sec id="s2a">
        <label>A.</label>
        <title>von Neumann algebras</title>
        <p>Since we formulate quantum error correction in an operator algebra framework, we begin by reviewing the structure of finite-dimensional von Neumann algebras. For a finite-dimensional complex Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula>, a von Neumann algebra on <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> is a complex vector space of linear operators acting on <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula>, which is closed under multiplication and Hermitian adjoint. Any such algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> can be characterized in the following way. The Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> contains a subspace with a direct sum decomposition, such that each summand is a product of two tensor factors: <disp-formula id="d1"><mml:math display="block"><mml:mrow><mml:mi mathvariant="script">H</mml:mi><mml:mo>⊇</mml:mo><mml:munder><mml:mrow><mml:mo>⨁</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(1)</label></disp-formula>where <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> has dimension <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> has dimension <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The von Neumann algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> can be expressed as <disp-formula id="d2"><mml:math display="block"><mml:mrow><mml:mi mathvariant="script">A</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>⨁</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(2)</label></disp-formula>where <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:math></inline-formula> denotes the algebra of <inline-formula><mml:math display="inline"><mml:msub><mml:mi>d</mml:mi><mml:mi>α</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:math></inline-formula> matrices and <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denotes the <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> identity matrix. The commutant <inline-formula><mml:math display="inline"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> contains all operators on <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula>, which commute with all operators in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, and can be expressed as <disp-formula id="d3"><mml:math display="block"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>⨁</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(3)</label></disp-formula>The center <inline-formula><mml:math display="inline"><mml:mi>Z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, which is also the center of its commutant, contains all elements of the form <disp-formula id="d4"><mml:math display="block"><mml:mrow><mml:munder><mml:mrow><mml:mo>⨁</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub><mml:mo>;</mml:mo></mml:mrow></mml:math><label>(4)</label></disp-formula>note that the center is Abelian.</p>
        <p>A nontrivial von Neumann algebra (with more than one summand) describes a quantum system with superselection sectors. We may regard <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula> as a label that specifies a sector with a specified value of a locally conserved charge. By focusing on <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, we focus our attention on operators that preserve <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula>. To interpret the decomposition, Eq. <xref ref-type="disp-formula" rid="d1">(1)</xref>, we imagine a system shared by two parties, Alice and Bob, where in each <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula> sector, the parties have equal and opposite charges. The algebras <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> capture the charge-preserving operations that can be applied by Alice and Bob, respectively. Equivalently, we may say that a nontrivial von Neumann algebra describes a system that encodes both classical and quantum information, where operators in the center <inline-formula><mml:math display="inline"><mml:mi>Z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="script">A</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> act only on the classical data (the label <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula>), while <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:math></inline-formula> acts on the quantum data in the sector labeled by <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula>.</p>
        <p>In OAQEC, we consider <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> to be a code subspace of a larger physical Hilbert space; hence, <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> are algebras of logical operators that preserve the code subspace. In the case where there is a single summand and <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mover accent="true"><mml:mi>α</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:msub></mml:math></inline-formula> is one dimensional, <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the complete algebra of logical operators. This is the standard setting of quantum error-correcting codes. If there is a single summand and <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mover accent="true"><mml:mi>α</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:msub></mml:math></inline-formula> is nontrivial, then <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the algebra of “bare” logical operators in a subsystem code. In this setting, the code subspace <disp-formula id="d5"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:msub></mml:mrow></mml:math><label>(5)</label></disp-formula>has a decomposition into a protected tensor factor <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:math></inline-formula> and a “gauge” factor <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mover accent="true"><mml:mi>α</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:msub></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> acts only on the protected system.</p>
        <p>The more general setting, with a nontrivial sum over <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula>, arises naturally in the context of holographic duality, where the code subspace corresponds to the low-energy sector of a conformal field theory whose gravitational dual is a bulk system with emergent gauge symmetry. The Abelian center <inline-formula><mml:math display="inline"><mml:mi>Z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> can, for example, encode classical data of the bulk geometry (see Ref. <xref ref-type="bibr" rid="c8">[8]</xref> for a recent tensor network interpretation). An important example of such a classical variable contained in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the area operator (see Ref. <xref ref-type="bibr" rid="c9">[9]</xref>) that arises in the Ryu-Takayanagi formula relating boundary entropy to bulk geometry.</p>
        <p>Another reason the OAQEC formalism is convenient in discussions of holography is that we can formulate the notion of complementary recovery <xref ref-type="bibr" rid="c10">[10]</xref> using this language. If the physical (boundary) Hilbert space has a decomposition as a product <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> of two subsystems, we may ask whether a subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> acting on the code space can be “reconstructed” as an algebra of physical operators with support on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, in which case we may say that erasure of <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> can be corrected for the algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>. We say that the code exhibits complementary recovery if the logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> can be reconstructed on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> and its commutant <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> can be reconstructed on <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. Equivalently, complementary recovery means that erasure of the physical subsystem <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> and erasure of the complementary physical subsystem <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula>.</p>
      </sec>
      <sec id="s2b">
        <label>B.</label>
        <title>Correctability</title>
        <p>Quantum error correction is a way of protecting properly encoded quantum states from the potentially damaging effects of noise with suitable properties. The noise can be described by a completely positive trace-preserving map (CPTP map), also called a quantum channel. A channel is a linear map that takes density operators to density operators; saying that the channel is “completely” positive means that the positivity of the density operator is preserved even when the channel acts on a system that is entangled with other systems.</p>
        <p>A channel <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> has an operator sum representation (also called a Kraus representation) of the form <disp-formula id="d6"><mml:math display="block"><mml:mrow><mml:mi mathvariant="script">N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mi>ρ</mml:mi><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(6)</label></disp-formula>where the condition <disp-formula id="d7"><mml:math display="block"><mml:mrow><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math><label>(7)</label></disp-formula>ensures that <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>tr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>tr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. The operators <inline-formula><mml:math display="inline"><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> appearing in the Kraus representation are called Kraus operators. If there is only one Kraus operator in the sum, then the map is unitary, taking pure states to pure states. If there are two or more linearly independent Kraus operators, the map <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> describes a decoherence process, in which pure states can evolve to mixed states.</p>
        <p>Equation <xref ref-type="disp-formula" rid="d6">(6)</xref> is the Schrödinger picture description of the channel, in which <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> maps states to states. Since we are particularly interested in whether operators (rather than states) are well protected against noise, we find it more convenient to consider the Heisenberg picture description in which states are fixed and operators evolve. In this picture, the noise acts on the operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> according to <disp-formula id="d8"><mml:math display="block"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mi>X</mml:mi><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(8)</label></disp-formula>We say that <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">N</mml:mi><mml:mi>†</mml:mi></mml:msup></mml:math></inline-formula> is the dual map of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula>, also called the adjoint map of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula>. The condition <xref ref-type="disp-formula" rid="d7">(7)</xref> ensures that <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">N</mml:mi><mml:mi>†</mml:mi></mml:msup></mml:math></inline-formula> maps the identity operator to itself.</p>
        <p>We consider a quantum system with Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> and a noise channel <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> acting on the system. Quantum error correction is a process that reverses the effect of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula>. This error-correction process is itself a channel, called the recovery channel and denoted <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula>. Unless <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> is unitary, error correction is not possible for arbitrary states of the system. Instead, we consider a subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula>, which is called a quantum error-correcting code (QECC), and we settle for a recovery channel that corrects <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> acting on states of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula>. We say that <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> corrects <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> on code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> if, for any density operator <inline-formula><mml:math display="inline"><mml:mi>ρ</mml:mi></mml:math></inline-formula> supported on <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula>, <disp-formula id="d9"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>∘</mml:mo><mml:mi mathvariant="script">N</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(9)</label></disp-formula>and we say that the noise channel <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> is correctable on <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> if there exists a recovery operator <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></inline-formula> that corrects <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula>.</p>
        <p>In the Heisenberg picture language, we may consider an algebra of logical operators that act on the code space. We denote the set of linear operators mapping <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> by <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>. If <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi></mml:math></inline-formula> denotes the orthogonal projector from <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula>, then an operator <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is logical if <inline-formula><mml:math display="inline"><mml:mo stretchy="false">[</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula>; hence, <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> maps <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> to itself: <disp-formula id="d10"><mml:math display="block"><mml:mrow><mml:mi>X</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi mathvariant="script">H</mml:mi><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(10)</label></disp-formula>It is clear from this definition that if <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> is logical, so is its Hermitian adjoint <inline-formula><mml:math display="inline"><mml:mrow><mml:msup><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> (because <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mi>†</mml:mi></mml:msup></mml:math></inline-formula>); furthermore, a linear combination of logical operators is logical and so is a product of logical operators. Hence, the set of all logical operators forms an algebra, which we call the complete logical operator of the code. The theory of operator algebra quantum error correction addresses whether a subalgebra of this complete logical algebra can be protected against noise.</p>
        <p>Sometimes, we are only interested in how a logical operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> acts on the code space, so we consider the corresponding operator <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>, which has support only on <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula>. Operators of this type are also closed under multiplication because, if <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> both commute with <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi></mml:math></inline-formula>, then <disp-formula id="d11"><mml:math display="block"><mml:mrow><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mo>·</mml:mo><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(11)</label></disp-formula>In other words, if <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is an algebra of logical operators in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, then <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi mathvariant="script">A</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> is an algebra of logical operators in <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Two logical operators <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> might differ as elements of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> yet act on the code space in the same way because <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:math></inline-formula>. In that case, we say that <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> are logically equivalent, denoted <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>X</mml:mi><mml:msub><mml:mrow><mml:mo>∼</mml:mo></mml:mrow><mml:mrow><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mover accent="true"><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
        <p>Now we can formulate the notion of error correction in the Heisenberg picture. <statement content-type="Definition" id="st1"><label><bold>Definition 1</bold> </label><p>(correctability). The noise channel <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> is correctable on the code space <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> with respect to the operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> if and only if there exists a recovery channel <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> such that <disp-formula id="d12"><mml:math display="block"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>∘</mml:mo><mml:mi mathvariant="script">N</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(12)</label></disp-formula></p></statement></p>
        <p>This means that the operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> and the recovered operator <inline-formula><mml:math display="inline"><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>∘</mml:mo><mml:mi mathvariant="script">N</mml:mi><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>†</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> act on the code space in the same way, though they may act differently on state vectors outside the code space. Because this condition is linear in <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, the operators with respect to which <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> is correctable form a linear space.</p>
        <p>In an important series of works <xref ref-type="bibr" rid="c4 c11 c12">[4,11,12]</xref>, culminating in Refs. <xref ref-type="bibr" rid="c5 c6">[5,6]</xref>, the necessary and sufficient conditions for correctability of a logical algebra were derived. <statement content-type="Theorem" id="st2"><label><bold>Theorem 1</bold> </label><p>(criterion for correctability). Given code subspace <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula> and logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, the noise channel <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> with Kraus operators <inline-formula><mml:math display="inline"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> if and only if <disp-formula id="d13"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>P</mml:mi><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math><label>(13)</label></disp-formula>for all <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> and each pair of Kraus operators <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>If <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the code’s complete logical algebra, Eq. <xref ref-type="disp-formula" rid="d13">(13)</xref> becomes <disp-formula id="d14"><mml:math display="block"><mml:mrow><mml:mi>P</mml:mi><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>P</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(14)</label></disp-formula>which is the well-known Knill-Laflamme error-correction condition <xref ref-type="bibr" rid="c13">[13]</xref>. More generally, Eq. <xref ref-type="disp-formula" rid="d13">(13)</xref> says that <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>P</mml:mi><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> lies in the commutant <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>. Invoking the general structure of von Neumann algebras reviewed in Sec. <xref ref-type="sec" rid="s2a">II A</xref>, we see from Eq. <xref ref-type="disp-formula" rid="d3">(3)</xref> that <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>P</mml:mi><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> is supported on the second factor of each summand. In effect, Eq. <xref ref-type="disp-formula" rid="d13">(13)</xref> means that the Knill-Laflamme condition is satisfied in each superselection sector of the logical algebra.</p>
      </sec>
      <sec id="s2c">
        <label>C.</label>
        <title>Erasure and reconstruction</title>
        <p>A noise channel of particular interest is the erasure channel. To define the erasure channel, we consider a decomposition of the Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> as a product of two tensor factors, <disp-formula id="d15"><mml:math display="block"><mml:mrow><mml:mi mathvariant="script">H</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>;</mml:mo></mml:mrow></mml:math><label>(15)</label></disp-formula>we will sometimes express this decomposition more succinctly as <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. Anticipating the geometrical interpretation of holographic codes, we call <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> a region and say that <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> is its complementary region. We say that <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is erased when the quantum information in <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is lost while the information in <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> is retained. A noise channel describing this process is <disp-formula id="d16"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>tr</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(16)</label></disp-formula>which is called the erasure map on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, or the depolarizing map on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>; it throws away the state of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> and replaces it by the fixed state <inline-formula><mml:math display="inline"><mml:msub><mml:mi>σ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula>.</p>
        <p>As for any noise channel, we say that the erasure channel <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">N</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> is correctable with respect to the operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> if there is a recovery operator <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> satisfying Eq. <xref ref-type="disp-formula" rid="d12">(12)</xref>. As a convenient shorthand, we say that the subsystem <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable if erasure of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable: <statement content-type="Definition" id="st3"><label><bold>Definition 2</bold> </label><p>(correctable subsystem). Given a code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> and a logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, a subsystem <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> if erasure of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is a correctable map with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>.</p></statement></p>
        <p>Whether <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable does not depend on how we choose the state <inline-formula><mml:math display="inline"><mml:msub><mml:mi>σ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> in Eq. <xref ref-type="disp-formula" rid="d16">(16)</xref>; if <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> recovers from <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula>, then <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>∘</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> recovers from <inline-formula><mml:math display="inline"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>tr</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>For the special case of erasure, the criterion for correctability in Theorem 1 simplifies. We may choose <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>∝</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, in which case the Kraus operators realizing <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> may be chosen to be (up to normalization) the complete set of Pauli operators supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, which constitute a complete basis for operators acting on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. More generally, we may realize <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> by taking the Kraus operators in Eq. <xref ref-type="disp-formula" rid="d6">(6)</xref> as a Haar average over the unitary operators supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. We conclude as follows: <statement content-type="Lemma" id="st4"><label><bold>Lemma 1</bold> </label><p>(criterion for correctability of a subsystem). Given code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> and logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, subsystem <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> if and only if <disp-formula id="d17"><mml:math display="block"><mml:mo stretchy="false">[</mml:mo><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math><label>(17)</label></disp-formula>for all <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> and every operator <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>.</p></statement></p>
        <p>Thus, erasure of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to a logical algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> if and only if <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> lies in the commutant <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> for any operator <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. Because <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> is logical (<inline-formula><mml:math display="inline"><mml:mo stretchy="false">[</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula>), this criterion can also be written as <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula>; that is, the commutator <inline-formula><mml:math display="inline"><mml:mo stretchy="false">[</mml:mo><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> maps the code space to its orthogonal complement. If <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the code’s complete logical algebra, the criterion for correctability of erasure becomes <disp-formula id="d18"><mml:math display="block"><mml:mrow><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mi>P</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(18)</label></disp-formula>the Knill-Laflamme criterion for erasure correction <xref ref-type="bibr" rid="c13">[13]</xref>.</p>
        <p>If erasure of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to logical operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, then it is possible to find an operator <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> that is logically equivalent to <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> (<inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:math></inline-formula>) such that <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> is supported on the complementary subsystem <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. Borrowing the language of the <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> correspondence, we may say that <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> can be “reconstructed” on <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. In the quantum information literature, one says that <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> can be “cleaned” on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, meaning that there is an equivalent logical operator that acts trivially on the correctable set.</p>
        <p>To see why this reconstruction is possible, we may consider the dual <inline-formula><mml:math display="inline"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> of the erasure map <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which satisfies <disp-formula id="d19"><mml:math display="block"><mml:mrow><mml:mi>tr</mml:mi><mml:mo mathvariant="bold" stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo mathvariant="bold" stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>tr</mml:mi><mml:mo mathvariant="bold" stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>ρ</mml:mi><mml:mo mathvariant="bold" stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(19)</label></disp-formula>By the definition of correctability, Eq. <xref ref-type="disp-formula" rid="d12">(12)</xref>, if <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, then there is a recovery map <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">R</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> which corrects erasure, such that <disp-formula id="d20"><mml:math display="block"><mml:mrow><mml:mi>P</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>∘</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo>∘</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(20)</label></disp-formula>Furthermore, the dual map <inline-formula><mml:math display="inline"><mml:msubsup><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>R</mml:mi><mml:mi>†</mml:mi></mml:msubsup></mml:math></inline-formula> takes any (not necessarily logical) operator <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> to an operator that acts trivially on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>: <disp-formula id="d21"><mml:math display="block"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(21)</label></disp-formula>We see that <inline-formula><mml:math display="inline"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo>∘</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is logically equivalent to <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> and supported on <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>; that is, it is a reconstruction of <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> on the complement of the erased subsystem.</p>
        <p>To understand Eq. <xref ref-type="disp-formula" rid="d21">(21)</xref>, we argue as follows. Consider a unitary map supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, under which <disp-formula id="d22"><mml:math display="block"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">↦</mml:mo><mml:msup><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>ρ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(22)</label></disp-formula>Hence, <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, and therefore, <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, from which we infer that <disp-formula id="d23"><mml:math display="block"><mml:mrow><mml:mi>tr</mml:mi><mml:mrow><mml:mo mathvariant="bold" stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>ρ</mml:mi><mml:mo mathvariant="bold" stretchy="false">)</mml:mo></mml:mrow><mml:mo indentalign="id" indenttarget="d23a1">=</mml:mo><mml:mi>tr</mml:mi><mml:mrow><mml:mo mathvariant="bold" stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo mathvariant="bold" stretchy="false">)</mml:mo></mml:mrow><mml:mspace linebreak="newline"/><mml:mo indentalign="id" indenttarget="d23a1">=</mml:mo><mml:mi>tr</mml:mi><mml:mrow><mml:mo mathvariant="bold" stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>ρ</mml:mi><mml:mo mathvariant="bold" stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(23)</label></disp-formula>If it holds for any state <inline-formula><mml:math display="inline"><mml:mi>ρ</mml:mi></mml:math></inline-formula>, Eq. <xref ref-type="disp-formula" rid="d23">(23)</xref> implies <disp-formula id="d24"><mml:math display="block"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>†</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><label>(24)</label></disp-formula>for any unitary <inline-formula><mml:math display="inline"><mml:msub><mml:mi>U</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula>. Equation <xref ref-type="disp-formula" rid="d21">(21)</xref> then follows. Thus, we have shown the following: <statement content-type="Lemma" id="st5"><label><bold>Lemma 2</bold> </label><p>(reconstruction). Given code subspace <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula> and logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, if subsystem <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, then <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> can be reconstructed on the complementary subsystem <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. In other words, for each logical operator in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, there is a logically equivalent operator supported on <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>.</p></statement></p>
      </sec>
      <sec id="s2d">
        <label>D.</label>
        <title>Distance and price</title>
        <p>In the standard theory of quantum error correction, we consider the physical Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> to have a natural decomposition as a tensor product of small subsystems, for example, a decomposition into <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> qubits (two-level systems); <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> is the length of the code. This decomposition is “natural” in the sense of being motivated by the underlying physics—e.g., each qubit might be carried by a separate particle, where the particles interact pairwise. Typically, we suppose that the code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> also has a decomposition into “logical” qubits, in other words, that the dimension of the code space is <inline-formula><mml:math display="inline"><mml:msup><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:msup></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> is a positive integer. We may define the distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> of the code as the size of the smallest set <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> of physical qubits for which erasure of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is not correctable. Equivalently, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> is the size of the smallest region that supports observables capable of distinguishing among distinct logical states. We use the notation <inline-formula><mml:math display="inline"><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> for a code with <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> physical qubits, <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> logical qubits, and distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula>. For a given <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula>, it is desirable for <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> to be as large as possible, but there is a trade-off: Larger <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> means smaller <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> and vice versa. This standard theory can be generalized in some obvious ways; for example, the dimension of the code subspace might not be a power of 2, or the physical Hilbert space might be decomposed into higher-dimensional subsystems rather than qubits.</p>
        <p>The distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> loosely characterizes the error-correcting power of the code. But if some encoded degrees of freedom are better protected than others, then a more refined characterization can be useful since the distance captures only the worst case. In holographic codes, in particular, bulk degrees of freedom far from the boundary are better protected than bulk degrees of freedom near the boundary. To describe the performance of a holographic code more completely, we may assign a distance value to each of the code’s logical subalgebras.</p>
        <p>As in the standard theory, we assume the physical Hilbert space is uniformly factorizable, <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">H</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">⊗</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is finite dimensional. In applications to quantum field theory, then, <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula> is the Hilbert space of a suitably regulated theory; for example, if the theory is defined on a spatial lattice, a subsystem with Hilbert space <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></inline-formula> resides at each lattice site. Guided by this picture, we refer to the elementary subsystem as a “site.” By a “region” <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> we mean a subset of the <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> sites, and the number of sites it contains is called the size of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, denoted <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>. We may now define the distance of a logical algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>. <statement content-type="Definition" id="st6"><label><bold>Definition 3</bold> </label><p>(distance). Given code subspace <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula> and logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, the distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is the size of the smallest region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> that is not correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>.</p></statement></p>
        <p>If <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the code’s complete logical algebra, then <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> coincides with the standard definition of distance for a subspace code. In the case of a subsystem code, if <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the algebra of “bare” logical operators that act nontrivially on the protected subsystem and trivially on the gauge subsystem, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is the size of the smallest region that supports a nontrivial “dressed” logical operator, one that acts nontrivially on the protected subsystem and might act on the gauge subsystem as well. In that case, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> coincides with the standard definition of distance for a subsystem code. More generally, we might want to consider multiple ways of decomposing <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> into a protected subsystem and its complement, and our definition assigns a distance to each of these protected subsystems.</p>
        <p>For a given code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> and logical algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, we may also consider the smallest possible region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> such that <italic>all</italic> operators in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> are supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. We call the size of this region the price of the algebra. <statement content-type="Definition" id="st7"><label><bold>Definition 4</bold> </label><p>(price). Given code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> and logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, the price <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is the size of the smallest region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> such that, for every operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, there is a logically equivalent operator <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> that is supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>.</p></statement></p>
        <p>As already noted, if region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to operator <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, then an operator logically equivalent to <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> can be reconstructed on the complementary region <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. In this sense, the notions of distance and price are dual to one another. The relation between distance and price can be formulated more precisely with some simple lemmas. <statement content-type="Lemma" id="st8"><label><bold>Lemma 3</bold> </label><p>(complementarity). Given code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> and logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> sites, the distance and price of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> obey <disp-formula id="d25"><mml:math display="block"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(25)</label></disp-formula></p></statement><statement content-type="Proof" id="st9"><label><italic>Proof.</italic>—</label><p>Consider a region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> that is correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> and also unextendable, meaning <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> has the property that adding any additional site makes it noncorrectable. Then, there are noncorrectable sets with <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> sites, and therefore <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>. Furthermore, since <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable, all operators in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> can be reconstructed on its complement <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>; hence, <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>. Adding these two inequalities yields Eq. <xref ref-type="disp-formula" rid="d25">(25)</xref>. □</p></statement></p>
        <p>We may anticipate that if a region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> supports a nontrivial logical algebra, then erasing <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> inflicts an irreversible logical error. This intuition is correct if the algebra is non-Abelian. Let us say that a logical subalgebra is non-Abelian if it contains two logical operators <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> are noncommuting. Then, we have the following: <statement content-type="Lemma" id="st10"><label><bold>Lemma 4</bold> </label><p>(no free lunch). Given code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> and non-Abelian logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, the distance and price of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> obey <disp-formula id="d26"><mml:math display="block"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(26)</label></disp-formula></p></statement><statement content-type="Proof" id="st11"><label><italic>Proof.</italic>—</label><p>Consider two logical operators <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> (both commuting with <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi></mml:math></inline-formula>), such that <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> are noncommuting. By the definition of <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, there is a region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> with <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> such that an operator <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>Y</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> logically equivalent to <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> is supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>; hence, <disp-formula id="d27"><mml:math display="block"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≠</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>P</mml:mi><mml:mover accent="true"><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mrow></mml:mover><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mi>X</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>P</mml:mi><mml:mover accent="true"><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mrow></mml:mover><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(27)</label></disp-formula>This result means that region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> does not satisfy the criterion for correctability in Lemma 1 and therefore is not correctable with respect to <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>. By the definition of distance, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, and Eq. <xref ref-type="disp-formula" rid="d26">(26)</xref> follows. □</p></statement></p>
        <p>If <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is Abelian, then Eq. <xref ref-type="disp-formula" rid="d26">(26)</xref> need not apply. Consider, for example, the three-qubit quantum repetition code, spanned by the states <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mn>000</mml:mn><mml:mo stretchy="false">⟩</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mn>111</mml:mn><mml:mo stretchy="false">⟩</mml:mo></mml:math></inline-formula>, and the logical algebra generated by <disp-formula id="d28"><mml:math display="block"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Z</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mrow></mml:mover><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mn>000</mml:mn><mml:mo stretchy="false">⟩</mml:mo><mml:mo stretchy="false">⟨</mml:mo><mml:mn>000</mml:mn><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mn>111</mml:mn><mml:mo stretchy="false">⟩</mml:mo><mml:mo stretchy="false">⟨</mml:mo><mml:mn>111</mml:mn><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(28)</label></disp-formula>This algebra has price <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> because the operator <inline-formula><mml:math display="inline"><mml:mi>Z</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>I</mml:mi></mml:math></inline-formula>, supported only on the first qubit, is logically equivalent to <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:math></inline-formula>. On the other hand, the distance is <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>; because the logical algebra can be supported on any one of the three physical qubits, it is protected against the erasure of any two qubits. Note that <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math></inline-formula>, saturating Eq. <xref ref-type="disp-formula" rid="d25">(25)</xref>.</p>
        <p>For a traditional subspace code, we may define the price of the code as the price of its complete logical algebra, just as we define the code’s distance to be the distance of its complete logical algebra. The price and distance of a code are constrained by an inequality, which can be derived from the subadditivity of von Neumann entropy. This constraint on price is a corollary to the following theorem. <statement content-type="Theorem" id="st12"><label><bold>Theorem 2</bold> </label><p>(constraint on correctable regions). Consider a code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> sites, and let <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>log</mml:mi><mml:mi>dim</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mi>log</mml:mi><mml:mi>dim</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Suppose that <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula> are two disjoint correctable regions. Then, <disp-formula id="d29"><mml:math display="block"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(29)</label></disp-formula></p></statement><statement content-type="Proof" id="st13"><label><italic>Proof.</italic>—</label><p>Let <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi></mml:math></inline-formula> denote the code block <inline-formula><mml:math display="inline"><mml:msubsup><mml:mi mathvariant="script">H</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">⊗</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>, let <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula> denote a reference system, and let <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo></mml:math></inline-formula> denote a state of <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:math></inline-formula> in which <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula> is maximally entangled with the code space. The criterion for correctability says that if <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is a correctable region, then for any operator <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula>; therefore, if <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> is supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> is supported on <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula>, <disp-formula id="d30"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">⟨</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo><mml:mo indentalign="id" indenttarget="d30a1">=</mml:mo><mml:mo stretchy="false">⟨</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>P</mml:mi><mml:mi>Y</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo><mml:mspace linebreak="goodbreak"/><mml:mo indentalign="id" indenttarget="d30a1">=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">⟨</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo><mml:mspace linebreak="newline"/><mml:mo indentalign="id" indenttarget="d30a1">=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">⟨</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo><mml:mspace linebreak="goodbreak"/><mml:mo indentalign="id" indenttarget="d30a1">=</mml:mo><mml:mo stretchy="false">⟨</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo><mml:mo stretchy="false">⟨</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(30)</label></disp-formula>Because <inline-formula><mml:math display="inline"><mml:mo stretchy="false">⟨</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">⊗</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">⟩</mml:mo></mml:math></inline-formula> factorizes for any <inline-formula><mml:math display="inline"><mml:mi>Y</mml:mi></mml:math></inline-formula> supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> supported on <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula>, we conclude that the marginal density operator of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mi>T</mml:mi></mml:math></inline-formula> factorizes, <disp-formula id="d31"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mi>T</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(31)</label></disp-formula>if <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable.</p><p>To proceed, we use properties of the entropy <disp-formula id="d32"><mml:math display="block"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:mi>tr</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mi>log</mml:mi><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(32)</label></disp-formula>where, for convenience, we define entropy using logarithms with base <inline-formula><mml:math display="inline"><mml:mi>dim</mml:mi><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></inline-formula>. Because <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula> are both correctable, <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>T</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mi>T</mml:mi></mml:math></inline-formula> are product states; therefore, <disp-formula id="d33"><mml:math display="block"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow><mml:mspace linebreak="goodbreak"/><mml:malignmark/></mml:math><label>(33)</label></disp-formula>Denoting by <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> the region of the code block complementary to <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, and noting that the overall state of <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mi>T</mml:mi></mml:math></inline-formula> is pure, we have <disp-formula id="d34"><mml:math display="block"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(34)</label></disp-formula><disp-formula id="d35"><mml:math display="block"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo></mml:math><label>(35)</label></disp-formula>adding these equations yields <disp-formula id="d36"><mml:math display="block"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo mathvariant="bold" stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo mathvariant="bold" stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><label>(36)</label></disp-formula><disp-formula id="d37"><mml:math display="block"><mml:mrow><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo mathvariant="bold" stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo mathvariant="bold" stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(37)</label></disp-formula>Since the mutual information <inline-formula><mml:math display="inline"><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo>;</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is non-negative (subadditivity of entropy), <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mspace linebreak="goodbreak"/><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>, we obtain Eq. <xref ref-type="disp-formula" rid="d29">(29)</xref>. □</p></statement><statement content-type="Corollary" id="st14"><label><bold>Corollary 1</bold> </label><p>(strong quantum Singleton bound). Consider a code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> sites, and where <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>log</mml:mi><mml:mi>dim</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mi>log</mml:mi><mml:mi>dim</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Then, the distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> and price <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi></mml:math></inline-formula> of the code obey <disp-formula id="d38"><mml:math display="block"><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mi>d</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo></mml:math><label>(38)</label></disp-formula></p></statement><statement content-type="Proof" id="st15"><label><italic>Proof.</italic>—</label><p>In Eq. <xref ref-type="disp-formula" rid="d29">(29)</xref>, choose <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> to be the complement of the smallest region that supports the logical algebra of the code (hence, <inline-formula><mml:math display="inline"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>), and choose <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula> to be any set of <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> qubits not contained in <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula>. Then, Eq. <xref ref-type="disp-formula" rid="d38">(38)</xref> follows. □</p></statement><statement content-type="Corollary" id="st16"><label><bold>Corollary 2</bold> </label><p>(quantum Singleton bound). Consider a code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> sites, and where <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>log</mml:mi><mml:mi>dim</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mi>log</mml:mi><mml:mi>dim</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Then, <disp-formula id="d39"><mml:math display="block"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(39)</label></disp-formula>where <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> is the code distance.</p></statement><statement content-type="Proof" id="st17"><label><italic>Proof.</italic>—</label><p>Combine Corollary 1 and Lemma 3. □</p></statement></p>
        <p>Because of its resemblance to the Singleton bound <disp-formula id="d40"><mml:math display="block"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mi>d</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:math><label>(40)</label></disp-formula>satisfied by classical <inline-formula><mml:math display="inline"><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> codes, Eq. <xref ref-type="disp-formula" rid="d39">(39)</xref> is called the quantum Singleton bound. We therefore call Eq. <xref ref-type="disp-formula" rid="d38">(38)</xref> the strong quantum Singleton bound. This bound is saturated, for example, by the [[7,1,3]] Steane code. In that case, the logical Pauli operators <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:math></inline-formula> can both be supported on a set of three qubits; therefore, the price is <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>, and the bound becomes <disp-formula id="d41"><mml:math display="block"><mml:mrow><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>-</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(41)</label></disp-formula></p>
        <p>This strong quantum Singleton bound constrains the distance and price of a traditional subspace code, and it is natural to wonder what we can say about similar constraints on the distance and price of a logical subalgebra. In Sec. <xref ref-type="sec" rid="s6">VI</xref>, we will see that for holographic codes, using more sophisticated entropic arguments, we can derive an operator algebra version of the strong quantum Singleton bound.</p>
      </sec>
    </sec>
    <sec id="s3">
      <label>III.</label>
      <title>HOLOGRAPHY AND QUANTUM ERROR CORRECTION</title>
      <p>The <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> correspondence <xref ref-type="bibr" rid="c14">[14]</xref> is a remarkable proposed equivalence between two theories—quantum gravity in the bulk of a (<inline-formula><mml:math display="inline"><mml:mi>D</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>)-dimensional asymptotically anti–de Sitter spacetime, and conformally invariant quantum field theory (CFT), without gravity, residing on the <inline-formula><mml:math display="inline"><mml:mi>D</mml:mi></mml:math></inline-formula>-dimensional boundary of the spacetime. A very complex dictionary relates operators acting in the bulk theory to the corresponding operators in the boundary theory. This dictionary is only partially understood, but it is known that local operators acting deep inside the bulk correspond to highly nonlocal operators acting on the boundary. Much evidence indicates that geometrical properties of the bulk theory are intimately related to the structure of quantum entanglement in the boundary theory <xref ref-type="bibr" rid="c15 c16">[15,16]</xref>. Further elucidation of this relationship should help to clarify how spacetime geometry can arise as an emergent property of a nongravitational theory.</p>
      <p>A puzzling feature of the correspondence is that a single bulk operator can be faithfully represented by a boundary operator in multiple ways. In a very insightful paper, Almheiri, Dong, and Harlow <xref ref-type="bibr" rid="c1">[1]</xref> suggested interpreting this ambiguity using the language of quantum error correction. According to their proposal, the low-energy sector of the boundary CFT can be viewed as a code subspace of the CFT Hilbert space, corresponding to weakly perturbed AdS geometry in the bulk, and the local operators acting on the bulk can be regarded as the logical operators acting on this code subspace. Local operators in the bulk can be reconstructed on the boundary in multiple ways, reflecting the property of quantum error-correcting codes that operators acting differently on the physical Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> may be logically equivalent when acting on the code subspace <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula>. High-energy states of the CFT, which are outside the code space, correspond to large black holes in the bulk.</p>
      <p>In Ref. <xref ref-type="bibr" rid="c2">[2]</xref>, holographic codes were constructed, which capture the features envisioned in Ref. <xref ref-type="bibr" rid="c1">[1]</xref>. Such codes provide a highly idealized lattice regularization of the <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> correspondence, with bulk and boundary lattice sites. The code subspace, or bulk Hilbert space, is (disregarding some caveats expressed below) a tensor product of finite-dimensional Hilbert spaces, one associated with each bulk site, and likewise, the boundary Hilbert space is a tensor product of finite-dimensional Hilbert spaces, one associated with each boundary site. The code defines an embedding of the bulk Hilbert space inside the boundary Hilbert space. The embedding map can be realized by a tensor network construction based on a uniform tiling of the negatively curved bulk geometry. This tensor network provides an explicit holographic dictionary, in particular, mapping each (logical) bulk local operator (with support on a single bulk site) to a corresponding physical nonlocal operator on the boundary (acting on many boundary sites).</p>
      <p>From the perspective of quantum coding theory, holographic codes are a family of quantum codes in which logical degrees of freedom have a pleasing geometrical interpretation, and as emphasized in Ref. <xref ref-type="bibr" rid="c3">[3]</xref>, this connection between coding and geometry can be extended beyond anti–de Sitter space. From the perspective of the <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> correspondence, holographic codes strengthen our intuition regarding how quantum error correction relates to emergent geometry. Both perspectives provide ample motivation for further developing these ideas.</p>
      <p>The precise sense in which the low-energy sector of a CFT realizes a quantum code remains rather murky. But loosely speaking, the logical operators are CFT operators that map low-energy states to other low-energy states. Operators that are logically equivalent act on the low-energy states in the same way, but they act differently on the high-energy states that are outside the code space. The algebra of logical operators needs to be truncated because acting on a state with a product of too many logical operators may raise the energy too high, and thus, the resulting state leaves the code space.</p>
      <p>From the bulk point of view, there is a logical algebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> associated with each bulk site <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>, and formally, the complete logical algebra of the code is, in a first approximation, <disp-formula id="d42"><mml:math display="block"><mml:mrow><mml:mi mathvariant="script">A</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo stretchy="false">⊗</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(42)</label></disp-formula>where the tensor product is over all bulk sites. However, implicitly, the number of bulk local operators needs to be small enough so that the backreaction on the geometry can be safely neglected. If so many bulk operators are applied that the bulk geometry is significantly perturbed, then the code space will need to be enlarged, as explained Sec. <xref ref-type="sec" rid="s3b">III B</xref>. A further complication is that gauge symmetry in the bulk may prevent the bulk algebra from factorizing as in Eq. <xref ref-type="disp-formula" rid="d42">(42)</xref>.</p>
      <p>The holographic dictionary determines how the logical operator subalgebra supported on a region in the bulk (a set of logical bulk sites) can be mapped to an operator algebra supported on a corresponding region on the boundary (a set of physical boundary sites). The geometrical interpretation of this relation between the bulk and boundary operator algebras will be elaborated in the following subsections.</p>
      <sec id="s3a">
        <label>A.</label>
        <title>Entanglement wedge reconstruction</title>
        <p>For holographic codes, whether a specified subsystem of the physical Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> is correctable with respect to a particular logical subalgebra can be formulated as a question about the bulk geometry. This connection between correctability and geometry is encapsulated by the entanglement wedge hypothesis <xref ref-type="bibr" rid="c17 c18 c19 c20">[17–20]</xref>, which holds in <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> <xref ref-type="bibr" rid="c21 c22">[21,22]</xref>. This hypothesis specifies the largest bulk region whose logical subalgebra can be represented on a given boundary region.</p>
        <p>The entanglement wedge hypothesis can be formulated for dynamical spacetimes, but for our purposes, it will suffice to consider a special case. We consider a smooth Riemannian manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, which may be regarded as a spacelike slice through a static bulk spacetime. Somewhat more generally, we may imagine that <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> is a slice through a Lorentzian manifold, which is invariant under time reversal about <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>. Any <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> can be locally extended to such a Lorentzian manifold, which solves the Einstein field equation without matter sources. To formulate the entanglement wedge hypothesis for this case, we need the concept of a minimal bulk surface embedded in <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>. We denote the boundary of <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> by <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula> and consider a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>. <statement content-type="Definition" id="st18"><label><bold>Definition 5</bold> </label><p>(Minimal surface). Given a Riemannian manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> with boundary <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>, the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> associated with a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula> is the minimum area co-dimension-one surface in <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> which separates <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> from its boundary complement <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> (see Fig. <xref ref-type="fig" rid="f1">1</xref> for some examples).</p></statement></p>
        <fig id="f1">
          <object-id>1</object-id>
          <object-id pub-id-type="doi">10.1103/PhysRevX.7.021022.f1</object-id>
          <label>FIG. 1.</label>
          <caption>
            <p>Geometric notions of minimal surface and entanglement wedge. In each diagram, we highlight a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> with a crayon stroke; the corresponding minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> is indicated, and the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> is shaded in green. On the left, <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> is a hyperboloid whose boundary <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula> has two connected components, where <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is one of those components (the one on the right). The minimal surface cuts the hyperboloid at its waist, and the entanglement wedge is everything to the right of <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula>. In the central diagram, <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> is the interior of a Euclidean ellipse; the boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula> has two connected components, and <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> also has two connected components. As shown, the connected components of <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> need not be homologous to <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, allowing <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to be significantly larger than <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>⊔</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. On the right, <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> is the Poincaré disc, portraying an infinite hyperbolic geometry. The minimal surface is a geodesic in the bulk with end points on <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>.</p>
          </caption>
          <graphic xlink:href="e021022_1.eps"/>
        </fig>
        <p>For the most part, we assume that the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> is unique and geometrically well defined. Some choices of geometry <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> and boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> admit more than one minimal surface, but one can usually slightly alter the choice of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> in order to make the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> unique. Note that, according to Definition 5, <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> have the same minimal surface.</p>
        <p>Now, we can define the entanglement wedge. <statement content-type="Definition" id="st19"><label><bold>Definition 6</bold> </label><p>(entanglement wedge). Given a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>, the entanglement wedge of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is a bulk region <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>⊆</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, whose boundary is <inline-formula><mml:math display="inline"><mml:mrow><mml:mo>∂</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≔</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> is the minimal surface for <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> (see Fig. <xref ref-type="fig" rid="f1">1</xref> for some examples).</p></statement></p>
        <p>Note that under the uniqueness assumption for the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula>, the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> of a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> and the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> of its boundary complement <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> cover the full bulk manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, and they intersect exclusively at the minimal surface. <statement content-type="Hypothesis" id="st20"><label><bold>Hypothesis 1</bold> </label><p>(geometric complementarity). Given a region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula> and its boundary complement <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>, we have that <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>As we will see, this geometric statement, which holds for a generic manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> and boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, leads to very strong code-theoretic guarantees under the entanglement wedge hypothesis.</p>
        <p>For a holographic code, the entanglement wedge hypothesis states a sufficient condition for a boundary region to be correctable with respect to the logical subalgebra supported at a site in the bulk. Because of Lemma 2, this condition also informs us that the logical subalgebra can be reconstructed on the complementary boundary region. Evoking the continuum limit of the regulated bulk theory, we will sometimes refer to a bulk site as a point in the bulk, though it will be implicit that associated logical subalgebra is finite dimensional and slightly smeared in space. <statement content-type="Hypothesis" id="st21"><label><bold>Hypothesis 2</bold> </label><p>(entanglement wedge hypothesis). If the bulk point <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> is contained in the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> of boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, then the complementary boundary region <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> is correctable with respect to the logical bulk subalgebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula>. Thus, for each operator in <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula>, there is a logically equivalent operator supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>.</p></statement></p>
        <p>This connection between holographic duality and operator algebra quantum error correction has many implications worth exploring.</p>
        <p>For a holographic code corresponding to a regulated boundary theory, there are a finite number of boundary sites, each describing a finite-dimensional subsystem. Thus, we can speak of the length <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> of the code, meaning the number of boundary sites, as well as the distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> and price <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi></mml:math></inline-formula> of the code (or of any logical subalgebra), which also take integer values. It is convenient, though, to imagine taking a formal continuum limit of the boundary theory in which the total boundary volume stays fixed as <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>∞</mml:mi></mml:math></inline-formula>, while maintaining a uniform number of boundary sites per unit boundary volume as determined by the bulk induced metric. Without intending to place restrictions on the dimension of <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, from now on, we use the term area when speaking about the size of a boundary region, and we save the term volume for describing the size of a bulk region. In the continuum limit, we may still mention <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi></mml:math></inline-formula>, but now taking real values; <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> becomes the total area of the boundary, while <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is the area of the smallest boundary region that is not correctable with respect to logical subalgebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is the area of the smallest boundary region that supports <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>. For now, to ensure that backreaction on the bulk geometry is negligible, we suppose that the bulk algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> has support on a constant number of points. In the formal continuum limit, then, the logical algebra has negligible dimension, in effect defining a <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi><mml:mo>≈</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> code if the size of the logical system is expressed in geometrical units.</p>
        <p>The entanglement wedge hypothesis has notable consequences for the logical subalgebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> supported at a bulk point <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. Consider the distance of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula>. For any boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> with boundary complement <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>, if <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula>. On the other hand, if <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> can be reconstructed on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>; arguing as in the proof of Lemma 4, <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> cannot be correctable with respect to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> if <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> supports <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> is non-Abelian. By geometric complementarity, either <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> or <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>; we conclude that <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> if and only if <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. By the definition of distance, then, <disp-formula id="d43"><mml:math display="block"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo>:</mml:mo><mml:mi>x</mml:mi><mml:menclose notation="updiagonalstrike" other="updiag2"><mml:mrow><mml:mo>∈</mml:mo></mml:mrow></mml:menclose><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(43)</label></disp-formula>assuming <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> is non-Abelian.</p>
        <p>Now consider the price of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula>. According to the entanglement wedge hypothesis, <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> can be reconstructed on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> if <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. On the other hand, if <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:menclose notation="updiagonalstrike" other="updiag1"><mml:mrow><mml:mo>∈</mml:mo></mml:mrow></mml:menclose><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> by geometric complementarity, and therefore, <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> can be reconstructed on <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. Because operators supported on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> commute with operators supported on <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>, it is not possible for <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> to be reconstructed on both <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> if <inline-formula><mml:math display="inline"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is non-Abelian. We conclude that <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> can be reconstructed on <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> if and only if <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. By the definition of price, then, <disp-formula id="d44"><mml:math display="block"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo>:</mml:mo><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(44)</label></disp-formula>assuming <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> is non-Abelian.</p>
        <p>Geometric complementarity says that <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> if and only if <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:menclose notation="updiagonalstrike" other="updiag1"><mml:mrow><mml:mo>∈</mml:mo></mml:mrow></mml:menclose><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Therefore, by comparing Eqs. <xref ref-type="disp-formula" rid="d43">(43)</xref> and <xref ref-type="disp-formula" rid="d44">(44)</xref>, we see that the expressions for the distance and the price are identical. Thus, we have shown the following: <statement content-type="Lemma" id="st22"><label><bold>Lemma 5</bold> </label><p>(price equals distance for a point). For a holographic code, let <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> be the non-Abelian logical algebra associated with a bulk point <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. Then, <disp-formula id="d45"><mml:math display="block"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math><label>(45)</label></disp-formula></p></statement></p>
        <p>Thus, in a holographic code, the bound <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in Lemma 4 is saturated by the logical subalgebra of a point. It is intriguing that a geometrical point admits this simple algebraic characterization, suggesting how geometrical properties might be ascribed to logical subalgebras in a broader setting.</p>
        <p>We can extend this reasoning to a bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> that contains a finite number of bulk points, continuing to assume that the number of operator insertions is sufficiently small that backreaction on the bulk geometry can be neglected and that the logical subalgebra factorizes as in Eq. <xref ref-type="disp-formula" rid="d42">(42)</xref>. In that case, a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is correctable with respect to the algebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> if it is correctable with respect to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> for each bulk point <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> in <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>. Therefore, <disp-formula id="d46"><mml:math display="block"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:munder><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(46)</label></disp-formula>Equation <xref ref-type="disp-formula" rid="d44">(44)</xref> can also be extended to a bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>: <disp-formula id="d47"><mml:math display="block"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≔</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo>:</mml:mo><mml:mi>X</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(47)</label></disp-formula>assuming that each nontrivial operator in <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> fails to commute with some other operator in <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>. If all points of <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> are contained in <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>, it follows that <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>.</p>
        <p>We emphasize again that these properties apply not only to AdS bulk geometry but also to other quantum code constructions satisfying geometric complementarity and the entanglement wedge hypothesis. Such codes were constructed in Ref. <xref ref-type="bibr" rid="c2">[2]</xref> for tensor networks associated with tilings of bulk geometries having nonpositive curvature. These results were extended to arbitrary graph connectivity in Ref. <xref ref-type="bibr" rid="c3">[3]</xref>, where a discrete generalization of the entanglement wedge hypothesis was found to be valid in the limit of large bond dimension. Taking a suitable limit, these codes can be viewed as regularized approximations to underlying smooth geometries.</p>
      </sec>
      <sec id="s3b">
        <label>B.</label>
        <title>Punctures in the bulk</title>
        <p>In quantum gravity, there is an upper limit on the dimension of the Hilbert space that can be encoded in a physical region known as the Bousso bound <xref ref-type="bibr" rid="c23">[23]</xref>; the log of this maximal dimension is proportional to the surface area of the region. When one attempts to surpass this limit, a black hole forms, with entropy proportional to the area of its event horizon.</p>
        <p>This feature of bulk quantum gravity can be captured by holographic codes, rather crudely, if we allow punctures in the bulk. A subsystem of the code space <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></inline-formula> resides along the edge of each such puncture, and the holographic tensor network provides an isometric embedding of this logical subsystem in the physical Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> that resides on the exterior boundary of the bulk geometry. This picture is crude because, in an actual gravitational theory, a black hole in the bulk would carry mass and modify the bulk curvature outside the black hole. For our purposes, this impact on the curvature associated with a puncture will not be particularly relevant, and we will, for the most part, ignore it here.</p>
        <p>In the continuum limit, we associate the holographic code with a Riemannian bulk manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> as in Sec. <xref ref-type="sec" rid="s3a">III A</xref>, but now the boundary <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula> is the union of two components: the exterior (physical) boundary, denoted <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula>, and the interior (logical) boundary, denoted <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>. The logical boundary is the union of the boundaries of all punctures. For the physical region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula>, we now need to distinguish between its boundary complement <inline-formula><mml:math display="inline"><mml:mrow><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> and its physical complement <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula>. The entanglement wedge hypothesis continues to apply, where now it is understood that the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> separates <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> from its boundary complement. In <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula>, this is called the homology constraint, meaning that <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊔</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the boundary of a bulk region.</p>
        <p>As we take the continuum limit <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>∞</mml:mi></mml:math></inline-formula> with the bulk geometry fixed, we assume as before that the density of sites per unit area on <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula> is uniform, with the same density on both the physical boundary and the logical boundary. If we assume as in Sec. <xref ref-type="sec" rid="s3a">III A</xref> that the bulk logical algebra outside of the punctures is supported on a bounded number of bulk points, then the size <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> of the logical system is determined by the area of the logical boundary: <disp-formula id="d48"><mml:math display="block"><mml:mrow><mml:mi>k</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(48)</label></disp-formula></p>
        <p>A holographic code without punctures obeys the celebrated Ryu-Takayanagi formula <xref ref-type="bibr" rid="c15">[15]</xref>, which asserts that for a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, the entanglement entropy of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> with its physical complement <inline-formula><mml:math display="inline"><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo>≔</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> is the area <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> of the minimal surface separating <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> from <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>, with area measured in the same units used to define <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>. To extend this formula to a manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> with punctures, we imagine introducing a reference system <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula> that is maximally entangled with the logical system <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> so that the joint state of <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>T</mml:mi><mml:mo>⊔</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow></mml:math></inline-formula> is pure. For a physical boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula>, the area <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> of the minimal surface separating <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> from its boundary complement <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo>⊔</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is the entanglement entropy of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> with <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi><mml:mo>⊔</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> in this pure state.</p>
        <p>One way to visualize the purifying reference system <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula> is inspired by the thermofield double construction used in <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> <xref ref-type="bibr" rid="c24">[24]</xref>. Given a manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> with physical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> and logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, we introduce a second copy <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> of the manifold, with physical boundary <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> and logical boundary <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> (see Fig. <xref ref-type="fig" rid="f2">2</xref>). Then, we join <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula>, obtaining manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula>, whose physical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi><mml:mover accent="true"><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> has two connected components. This construction describes two holographic codes, whose logical systems are maximally entangled; the second copy of the code provides the reference system purifying the first copy. The combined manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> has no punctures, and we can apply the original formulation of the Ryu-Takayanagi formula to <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula>. For a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula>, the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> separating <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> from <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mo>⊔</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> never reaches into <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula>, and therefore, it coincides with the minimal surface separating <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> from <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo>⊔</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>. [We note that if the logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> represents the event horizon of a static (<inline-formula><mml:math display="inline"><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>)-dimensional black hole, then, because a geodesic outside the black hole is the spatial trajectory of a light ray, <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> either fully contains <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> or avoids it entirely. For a nonstatic geometry, it is possible for <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> to include only part of <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>.]</p>
        <fig id="f2">
          <object-id>2</object-id>
          <object-id pub-id-type="doi">10.1103/PhysRevX.7.021022.f2</object-id>
          <label>FIG. 2.</label>
          <caption>
            <p>The left diagram illustrates the thermofield double construction, in which a bulk manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> with logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> is extended to two copies of <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> with their logical boundaries identified. This doubled manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> describes two holographic codes whose logical systems are maximally entangled. The other two diagrams illustrate that, for a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> contained in the physical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, the corresponding minimal surface lies in <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>.</p>
          </caption>
          <graphic xlink:href="e021022_2.eps"/>
        </fig>
        <p>The Ryu-Takayanagi formula relating entanglement entropy <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> to <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> is actually the leading term in a systematic expansion <xref ref-type="bibr" rid="c25">[25]</xref>, in which the next correction arises from entanglement among bulk degrees of freedom, specifically the bulk entanglement of <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> with its bulk complement. In fact, the division of <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> into the geometrical contribution <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> and the bulk entanglement contribution is not a renormalization group invariant; the geometrical contribution dominates in the extreme low-energy limit of the boundary theory, and the bulk entropy becomes more important as we probe the boundary theory at shorter and shorter distances. We implicitly work in the low-energy limit in which geometrical entanglement is dominant. Even in this framework, it is possible to include bulk entanglement in our discussion, in accordance with the so-called <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>ER</mml:mi><mml:mo>=</mml:mo><mml:mi>EPR</mml:mi></mml:mrow></mml:math></inline-formula> principle <xref ref-type="bibr" rid="c26">[26]</xref>, which identifies entanglement with wormhole connectedness. For example, we can consider two punctures of equal size in the bulk and identify their logical boundaries <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, so the two logical systems are maximally entangled. If <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is sufficiently large, the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> in the bulk might pass in between the two punctures and include (say) the logical boundary <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> in order to satisfy the homology constraint. Then, the entanglement entropy of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> includes a contribution <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> due to inclusion of the puncture in its entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. In this way, the geometrical entanglement of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> can capture the bulk entanglement shared by the punctures.</p>
        <p>Up until now, we have implicitly assumed that the holographic code provides an isometric embedding of the logical system <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> into the physical system <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula>. This requirement places restrictions on the geometry of the puncture(s). The Ryu-Takayanagi formula provides one possible way to understand the restriction. Suppose that the reference system <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula> is maximally entangled with the logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> so that the state of <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi><mml:mo>⊔</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> is pure, and the entanglement entropy of <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> is <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>. This must agree with the geometrical entropy given by <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi mathvariant="normal">Φ</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi mathvariant="normal">Λ</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>, the area of the minimal surface separating <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>. Holographic tensor network constructions suggest a stronger constraint, <disp-formula id="d49"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(49)</label></disp-formula>since in that case, the tensor network provides an explicit isometric map from <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> into <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula>. This consistency condition is illustrated in Fig. <xref ref-type="fig" rid="f3">3</xref>. The constraint equation <xref ref-type="disp-formula" rid="d49">(49)</xref> ensures that the geometrical entanglement entropy <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is compatible with the Bekenstein-Hawking entropy <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> of a black hole with event horizon at <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, as we should expect when the microstates of the black hole are maximally entangled with a reference system. If several such black holes approach one another, they must coalesce into a larger black hole in order to enforce Eq. <xref ref-type="disp-formula" rid="d49">(49)</xref>. See Fig. <xref ref-type="fig" rid="f3">3</xref>.</p>
        <fig id="f3">
          <object-id>3</object-id>
          <object-id pub-id-type="doi">10.1103/PhysRevX.7.021022.f3</object-id>
          <label>FIG. 3.</label>
          <caption>
            <p>Necessary condition <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi mathvariant="normal">Λ</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> for the interior boundary of a Riemannian manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> to be identified as a logical system. In both diagrams, the physical Hilbert space <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> resides on the exterior boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> is the boundary of the punctures in the bulk, which are shaded in black. The green region is the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>, bounded by <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> and the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi mathvariant="normal">Φ</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi mathvariant="normal">Λ</mml:mi></mml:msub></mml:math></inline-formula> separating <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> from <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>; the gray region is <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi><mml:mo>\</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. For purposes of illustration, we assume the bulk metric is Euclidean. On the left, we have <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi mathvariant="normal">Λ</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, and the interpretation of <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> as a logical system is consistent. On the right, we have <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi mathvariant="normal">Λ</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, and two possible reasons for this are illustrated. First, a connected component of <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> may fail to be convex. Second, the union <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> of several connected components of <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> may be encapsulated by a surface <inline-formula><mml:math display="inline"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> with smaller area than <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula>, in which case the logical system resides on <inline-formula><mml:math display="inline"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> rather than <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula>. The emergence of this new logical system is reminiscent of the merging of small black holes to form a larger black hole.</p>
          </caption>
          <graphic xlink:href="e021022_3.eps"/>
        </fig>
        <p>For a holographic code with punctures, we may consider the logical subalgebra associated with a bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi><mml:mo>⊆</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>, where now <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> may include pieces of <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>. Because we are considering the low-energy regime in which geometric entanglement dominates bulk entanglement and backreaction on the geometry due to bulk fields is negligible, we ignore the contribution of bulk points to the logical subalgebra, just as in Eq. <xref ref-type="disp-formula" rid="d48">(48)</xref>. Therefore, if <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> does intersect with <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, then the effective size of the logical system is given by <disp-formula id="d50"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo>∩</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(50)</label></disp-formula>the area of the portion of <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> contained in <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>. (In the language of holographic tensor network codes <xref ref-type="bibr" rid="c2">[2]</xref>, we are assuming that most bulk tensors carry no logical indices, so nearly all of the bulk logical indices contained in the bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> are located on the logical boundary.)</p>
        <p>For bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, we consider a reference system <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula> that is maximally entangled with the logical subsystem residing in <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi><mml:mo>⊆</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>. Then, when we say that <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> can be reconstructed on boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula>, we mean that <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> contains a subsystem that is maximally entangled with <inline-formula><mml:math display="inline"><mml:mi>T</mml:mi></mml:math></inline-formula>. If we apply the entanglement wedge hypothesis to a manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> with a logical boundary, we can use the same reasoning as in Sec. <xref ref-type="sec" rid="s3a">III A</xref> to obtain a geometrical expression for the price of the logical algebra: <disp-formula id="d51"><mml:math display="block"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≔</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>:</mml:mo><mml:mi>X</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(51)</label></disp-formula>On the other hand, a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> will be correctable with respect to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> if <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> is supported on the physical complement <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, and the expression for distance becomes <disp-formula id="d52"><mml:math display="block"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≔</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>:</mml:mo><mml:mi>X</mml:mi><mml:menclose notation="updiagonalstrike" other="updiag1"><mml:mrow><mml:mo>⊆</mml:mo></mml:mrow></mml:menclose><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(52)</label></disp-formula>It is important to notice that the minimization in <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is over <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> not contained in the entanglement wedge of the physical complement, rather than the boundary complement, of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. In particular, when <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> is a single point <inline-formula><mml:math display="inline"><mml:mo stretchy="false">{</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> in the bulk, the expressions for price and distance are not identical because the entanglement wedges <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> are not complementary regions of the bulk. Therefore, Lemma 5 does not apply to the case of a bulk manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> with logical boundaries.</p>
        <p>The geometrical interpretations for price and distance of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> allow us to prove a version of the strong quantum Singleton bound that applies to subalgebras with nonvanishing <inline-formula><mml:math display="inline"><mml:msub><mml:mi>k</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> in the continuum limit. This will be explained in Sec. <xref ref-type="sec" rid="s6">VI</xref>.</p>
      </sec>
    </sec>
    <sec id="s4">
      <label>IV.</label>
      <title>NEGATIVE CURVATURE AND UBERHOLOGRAPHY</title>
      <p>Next, we discuss a general property of holographic codes defined on bulk manifolds with asymptotically uniform negative curvature, which we call uberholography. The essence of uberholography is that both the distance and price of a logical subalgebra scale sublinearly with the length <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> of the holographic code. In the formal continuum limit <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>∞</mml:mi></mml:math></inline-formula>, the logical subalgebra can be supported on a fractal subset of the boundary, with fractal dimension strictly less than the dimension of the boundary. This fractal dimension is a universal feature of the code, in the sense that it does not depend on which logical subalgebra we consider. Uberholography is intriguing, as it suggests that (<inline-formula><mml:math display="inline"><mml:mrow><mml:mi>D</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>)-dimensional bulk geometry can emerge, not just from an underlying <inline-formula><mml:math display="inline"><mml:mi>D</mml:mi></mml:math></inline-formula>-dimensional system, but also from a system of even lower dimension.</p>
      <p>Though uberholography applies more generally, to be concrete, we consider the bulk to have a two-dimensional hyperbolic geometry with radius of curvature <inline-formula><mml:math display="inline"><mml:mi>L</mml:mi></mml:math></inline-formula>. Now the boundary is one dimensional, and the minimal “surface” <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> associated with connected boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is really a bulk geodesic, whose “area” is actually the geodesic’s length. For our purpose, we need to know only one feature of the bulk geometry: For an interval <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> on the boundary with length <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>, the length of the bulk geodesic <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> separating <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> from its boundary complement is <disp-formula id="d53"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>L</mml:mi><mml:mi>log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(53)</label></disp-formula>Here, <inline-formula><mml:math display="inline"><mml:mi>a</mml:mi></mml:math></inline-formula> is a short-distance cutoff, which we may think of as a lattice spacing for the boundary theory, so <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi></mml:math></inline-formula> is the number of boundary sites contained in <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. Applying the Ryu-Takayanagi formula, we conclude that the entanglement entropy <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> scales logarithmically with the size of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, which is the expected result for the vacuum state of a CFT in one spatial dimension.</p>
      <p>For some bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, we compute the distance of the logical subalgebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> associated with <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>. This distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is the size of the smallest boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> which is not correctable with respect to <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>. Pick a point <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> in <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, and choose a connected boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>, but just barely—if we choose a slightly smaller connected boundary region <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>⊂</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula>, then <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> will not contain <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. Since <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, we know that <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is not correctable with respect to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula>, and therefore <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mspace linebreak="goodbreak"/><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>. We could get a tighter upper bound on <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> if we find a smaller boundary region <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>⊂</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula> whose entanglement wedge still contains <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. There may be no such connected boundary region, but can we find a disconnected <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>⊂</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>?</p>
      <p>Let us try punching a hole in <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. In other words, we divide <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> into three consecutive disjoint intervals <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>H</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, where <disp-formula id="d54"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo indentalign="id" indenttarget="d54a1">=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:mspace linebreak="goodbreak"/><mml:mo stretchy="false">|</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo indentalign="id" indenttarget="d54a1">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:mspace linebreak="goodbreak"/><mml:mn>0</mml:mn><mml:mo indentalign="id" indenttarget="d54a1">&lt;</mml:mo><mml:mi>r</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(54)</label></disp-formula>and then remove the middle (hole) interval <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>, leaving the disconnected region <inline-formula><mml:math display="inline"><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mo>\</mml:mo><mml:mi>H</mml:mi></mml:mrow></mml:math></inline-formula>. There are two possible ways to choose bulk geodesics that separate <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> from its complement (illustrated in Fig. <xref ref-type="fig" rid="f4">4</xref>), either <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:math></inline-formula> or <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:math></inline-formula>; the minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub></mml:math></inline-formula> is the smaller of these two. Thus, if <disp-formula id="d55"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(55)</label></disp-formula>we get <disp-formula id="d56"><mml:math display="block"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>\</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>;</mml:mo></mml:mrow></mml:math><label>(56)</label></disp-formula>removing <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> from <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> has the effect of removing <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> from <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. Therefore, <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> still contains <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>, and hence <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>.</p>
      <fig id="f4">
        <object-id>4</object-id>
        <object-id pub-id-type="doi">10.1103/PhysRevX.7.021022.f4</object-id>
        <label>FIG. 4.</label>
        <caption>
          <p>Two possible geometries for the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> of a boundary region <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula> with two connected components separated by the interval <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>. In the left diagram, the minimal surface is <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:math></inline-formula>, and the entanglement wedge is <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>⊔</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. In the right diagram, the minimal surface is <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>H</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, and the entanglement wedge is <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>\</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>.</p>
        </caption>
        <graphic xlink:href="e021022_4.eps"/>
      </fig>
      <p>If we choose <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> as large as possible, while respecting Eq. <xref ref-type="disp-formula" rid="d55">(55)</xref>, then Eq. <xref ref-type="disp-formula" rid="d53">(53)</xref> implies <disp-formula id="d57"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>⇒</mml:mo><mml:msup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">/</mml:mo><mml:mn>4</mml:mn><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(57)</label></disp-formula>which is satisfied by <disp-formula id="d58"><mml:math display="block"><mml:mi>r</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo></mml:math><label>(58)</label></disp-formula>Each connected component of <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> is smaller than <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> by this factor.</p>
      <p>Now we repeat this construction recursively. In each round of the procedure, we start with a disconnected region <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover></mml:math></inline-formula> is the union of many connected components of equal size. Then, we punch a hole out of each connected component to obtain a new region <inline-formula><mml:math display="inline"><mml:msup><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo accent="true" stretchy="false">˜</mml:mo></mml:mover><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> still contains <inline-formula><mml:math display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. Punching the holes increases the number of connected components by a factor of 2 and reduces the size of each component by a factor of <inline-formula><mml:math display="inline"><mml:mi>r</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>.</p>
      <p>The procedure halts when the connected components are reduced in size to the lattice spacing <inline-formula><mml:math display="inline"><mml:mi>a</mml:mi></mml:math></inline-formula>, which occurs after <inline-formula><mml:math display="inline"><mml:mi>m</mml:mi></mml:math></inline-formula> rounds, where <disp-formula id="d59"><mml:math display="block"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(59)</label></disp-formula>The remaining region <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>min</mml:mi></mml:msub></mml:math></inline-formula> has <inline-formula><mml:math display="inline"><mml:msup><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:msup></mml:math></inline-formula> components, each containing one lattice site. so that <disp-formula id="d60"><mml:math display="block"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(60)</label></disp-formula>where <disp-formula id="d61"><mml:math display="block"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>log</mml:mi><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msqrt><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msqrt><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>≈</mml:mo><mml:mn>0.786</mml:mn><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(61)</label></disp-formula>The initial interval <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is surely no larger than the whole boundary, so the distance is bounded above by <inline-formula><mml:math display="inline"><mml:msup><mml:mi>n</mml:mi><mml:mi>α</mml:mi></mml:msup></mml:math></inline-formula> for any logical subalgebra, where <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> are expressed as a number of boundary sites (rather than length along the boundary).</p>
      <p>We can also consider codes with punctures in the bulk. To be specific, suppose <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> is a hyperbolic disk of proper radius <inline-formula><mml:math display="inline"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>out</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, with a single puncture at the center of radius <inline-formula><mml:math display="inline"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>in</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. The code length <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> is proportional to the circumference of the outer boundary, and the size <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> of the logical system is proportional to the circumference of the inner boundary. Because the circumference of a circle with radius <inline-formula><mml:math display="inline"><mml:mi>r</mml:mi></mml:math></inline-formula> is <inline-formula><mml:math display="inline"><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>L</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, the rate of the code is <disp-formula id="d62"><mml:math display="block"><mml:mrow><mml:mi>k</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>in</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>out</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(62)</label></disp-formula>We may choose an interval <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> on the boundary, such that <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> is tangent to the inner boundary at a single point. The length of this geodesic is essentially twice the difference between the inner and outer boundaries, so Eq. <xref ref-type="disp-formula" rid="d53">(53)</xref> implies <disp-formula id="d63"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>out</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>in</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mi>log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(63)</label></disp-formula>Using the recursive construction to repeatedly carve holes out of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, we obtain the bound Eq. <xref ref-type="disp-formula" rid="d60">(60)</xref> on the code distance, which becomes <disp-formula id="d64"><mml:math display="block"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≤</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>out</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>in</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math><label>(64)</label></disp-formula>(with the code distance expressed as a number of boundary sites). This scaling of the code distance, with <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi><mml:mo>≈</mml:mo><mml:mn>0.786</mml:mn></mml:math></inline-formula>, compares favorably with the bound <xref ref-type="bibr" rid="c27">[27]</xref> on local commuting projector codes defined on a two-dimensional Euclidean lattice, for which <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>.</p>
      <p>The scaling <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> applies to price as well as distance. Once we have found a sufficiently large boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> contains the bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, we can proceed to hollow out <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> recursively until we reach the much smaller region <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>min</mml:mi></mml:msub></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>min</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>α</mml:mi></mml:msup></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>min</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> still contains <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, and hence <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> is supported on <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>min</mml:mi></mml:msub></mml:math></inline-formula>. The resulting region <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>min</mml:mi></mml:msub></mml:math></inline-formula>, with fractal dimension <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula>, has a geometry reminiscent of the Cantor set, as illustrated in Fig. <xref ref-type="fig" rid="f5">5</xref>.</p>
      <fig id="f5">
        <object-id>5</object-id>
        <object-id pub-id-type="doi">10.1103/PhysRevX.7.021022.f5</object-id>
        <label>FIG. 5.</label>
        <caption>
          <p>This figure illustrates uberholography for the case of a two-dimensional hyperbolic bulk geometry. The inner logical boundary is contained inside the entanglement wedge, shaded in blue, of a boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. By repeatedly punching holes of decreasing size out of this boundary region, we obtain a much smaller region <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>min</mml:mi></mml:msub></mml:math></inline-formula> whose entanglement wedge still contains the logical boundary. Thus, the logical algebra is supported on a fractal boundary set, whose geometry is reminiscent of the Cantor set.</p>
        </caption>
        <graphic xlink:href="e021022_5.eps"/>
      </fig>
      <p>It is interesting to compare this universal exponent <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula> for planar uberholography with the scaling laws for distance and price realized by other code families, such as holographic tensor network codes and concatenated quantum codes. In fact, it can be quite challenging to obtain tight lower bounds on distance and price for tensor network code constructions; see the Appendix for further discussion.</p>
    </sec>
    <sec id="s5">
      <label>V.</label>
      <title>QUANTUM MARKOV CONDITION AND LOCAL CORRECTABILITY</title>
      <p>For a holographic code, consider (as in Sec. <xref ref-type="sec" rid="s4">IV</xref>) a connected region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>H</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, which is the disjoint union of three adjoining intervals. Imagine that the middle interval <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> is erased. If <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> is correctable, there is a recovery map <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> that corrects this erasure error. However, now we ask whether a stronger condition is satisfied: Is it possible to choose a recovery map taking <inline-formula><mml:math display="inline"><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> so that <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">R</mml:mi><mml:mrow><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>H</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> “fills in” the erased hole <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>? If the erasure of <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> can be corrected by a map that acts only on a somewhat larger region containing <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> (larger by a constant factor independent of system size), then we say that erasure is locally correctable.</p>
      <p>The quantum Markov condition provides a criterion for local correctability <xref ref-type="bibr" rid="c28">[28]</xref>. We say that the state <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> of three disjoint regions <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>C</mml:mi></mml:math></inline-formula> obeys the quantum Markov condition (also called quantum conditional independence) if <disp-formula id="d65"><mml:math display="block"><mml:mrow><mml:mn>0</mml:mn><mml:mo>=</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>;</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(65)</label></disp-formula>which is equivalent to saying that the strong subadditivity inequality is saturated (satisfied as an equality). If the Markov condition is satisfied, then <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> can be reconstructed from the marginal state <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> using a map <inline-formula><mml:math display="inline"><mml:msup><mml:mi mathvariant="script">R</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, which maps <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:math></inline-formula>: <disp-formula id="d66"><mml:math display="block"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mtext> </mml:mtext><mml:mtext> </mml:mtext><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">↦</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(66)</label></disp-formula>known as the Petz recovery map <xref ref-type="bibr" rid="c29">[29]</xref>. See Ref. <xref ref-type="bibr" rid="c30">[30]</xref> for a construction of a map that is robust to condition <xref ref-type="disp-formula" rid="d65">(65)</xref> holding only approximately. Likewise, in view of the symmetry of the condition under the interchange of <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>C</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> can be reconstructed from <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> by a map from <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> to <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi><mml:mi>B</mml:mi></mml:math></inline-formula>.</p>
      <p>In fact, Eq. <xref ref-type="disp-formula" rid="d65">(65)</xref> implies that <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula> has a decomposition as a direct sum of tensor products of Hilbert spaces, <disp-formula id="d67"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>⨁</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>⨁</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(67)</label></disp-formula>and that the state of <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:math></inline-formula> has the block-diagonal form <disp-formula id="d68"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>⨁</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo stretchy="false">⊗</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msubsup><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(68)</label></disp-formula>Evidently, we can recover <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> from <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> by replacing each <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:msubsup><mml:mi>B</mml:mi><mml:mi>j</mml:mi><mml:mi>R</mml:mi></mml:msubsup></mml:msub></mml:math></inline-formula> by <inline-formula><mml:math display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:msubsup><mml:mi>B</mml:mi><mml:mi>j</mml:mi><mml:mi>R</mml:mi></mml:msubsup><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, without touching the system <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi></mml:math></inline-formula>.</p>
      <p>To apply the Markov condition to our holographic setting, consider a holographic code with no punctures, where the state of the physical boundary is pure. We choose <inline-formula><mml:math display="inline"><mml:mi>A</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>C</mml:mi></mml:math></inline-formula> to be three disjoint regions whose union is the complete boundary, namely, <disp-formula id="d69"><mml:math display="block"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(69)</label></disp-formula>where <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> denotes the boundary region complementary to <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>. Because the state of the complete boundary is pure, <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>H</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>; therefore, the condition Eq. <xref ref-type="disp-formula" rid="d65">(65)</xref> becomes <disp-formula id="d70"><mml:math display="block"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">⇔</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math><label>(70)</label></disp-formula>When this condition is satisfied, <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> can be divided into two subsystems, where one purifies the state of <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> and the other purifies the state of <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula>. To correct the erasure of <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>, we need only restore the entanglement between <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>, and for this purpose, there is no need to venture outside <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>.</p>
      <sec id="s5a">
        <label>A.</label>
        <title>Hyperbolic bulk</title>
        <p>Using the Ryu-Takayanagi formula, this statement Eq. <xref ref-type="disp-formula" rid="d70">(70)</xref> about entropy would follow from a statement about minimal surfaces: <disp-formula id="d71"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(71)</label></disp-formula>which is the same as the condition (discussed in Sec. <xref ref-type="sec" rid="s4">IV</xref>) for the entanglement wedge <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to be <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>\</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. For the case in which the bulk is a hyperbolic disk, the calculation in Sec. <xref ref-type="sec" rid="s4">IV</xref> shows that erasure of <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> can be corrected by a recovery map that acts on region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> containing <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>r</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:msqrt><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msqrt><mml:mo>≈</mml:mo><mml:mn>5.828</mml:mn></mml:mrow></mml:math></inline-formula>. Thus, the erasure error is locally correctable. This local correctability is a general feature of holographic codes with asymptotically uniform negative bulk curvature.</p>
        <p>We may also consider the case of a manifold with punctures, where the logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> is maximally entangled with a reference system. In that case, the entropy of the physical boundary matches <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, and the Markov condition is satisfied provided that <disp-formula id="d72"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(72)</label></disp-formula>which holds if <disp-formula id="d73"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mo>⊔</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(73)</label></disp-formula>As for the case without punctures, Eq. <xref ref-type="disp-formula" rid="d73">(73)</xref> will be satisfied if <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> is a sufficiently small interval on the physical boundary of the hyperbolic disk and <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> is an interval containing <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> is larger than <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> by a constant factor. The interpretation is the same as before; Eq. <xref ref-type="disp-formula" rid="d73">(73)</xref> implies that <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula> contains a subsystem that purifies <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>, so there is no need to reach outside of <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> to recover from the erasure of <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>.</p>
        <p>It is also notable that if the Markov condition Eq. <xref ref-type="disp-formula" rid="d65">(65)</xref> is <italic>approximately</italic> satisfied, then a local recovery map can be constructed which approximately corrects the erasure of <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>. This is important because in realistic <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula>, the Markov condition is not exactly satisfied because of the small corrections to the Ryu-Takayanagi formula, which we have neglected. Local correctability in the approximate setting has been discussed recently in Refs. <xref ref-type="bibr" rid="c28 c31 c32">[28,31,32]</xref>.</p>
        <p>While holographic codes based on tensor networks can successfully reproduce the Ryu-Takayanagi relation satisfied by the von Neumann entanglement entropy of the boundary theory <xref ref-type="bibr" rid="c2 c3">[2,3]</xref>, they do not correctly capture the properties of Rényi entropies <xref ref-type="bibr" rid="c33 c34 c35">[33–35]</xref> and therefore do not provide a fully satisfactory description of conformal field theories with dual geometries. It is fortunate that the Markov condition Eq. <xref ref-type="disp-formula" rid="d65">(65)</xref>, and its approximate version <xref ref-type="bibr" rid="c36">[36]</xref>, is stated in terms of von Neumann entanglement entropies. We therefore expect that holographic tensor network codes can provide a reasonable picture of local correctability in realistic holography.</p>
      </sec>
      <sec id="s5b">
        <label>B.</label>
        <title>Flat bulk</title>
        <p>The criterion for local correctability is satisfied by generic negatively curved bulk geometries but not by bulk geometries that are flat or positively curved. Consider, for example, a Euclidean two-dimensional disk with unit radius. For an interval <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> on the boundary that subtends angle <inline-formula><mml:math display="inline"><mml:mi>θ</mml:mi></mml:math></inline-formula>, the geodesic <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> is a chord of the boundary circle with length <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>sin</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>. Suppose we erase a hole <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula> that subtends angle <inline-formula><mml:math display="inline"><mml:mn>2</mml:mn><mml:mi>δ</mml:mi></mml:math></inline-formula> and correct the erasure by acting in a larger region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> that contains <inline-formula><mml:math display="inline"><mml:mi>H</mml:mi></mml:math></inline-formula>. If <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>H</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula> subtends angle <inline-formula><mml:math display="inline"><mml:mn>2</mml:mn><mml:mi>ϕ</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>, the Markov condition can be satisfied only if <disp-formula id="d74"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo indentalign="id" indenttarget="d74a1">=</mml:mo><mml:mn>4</mml:mn><mml:mi>sin</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>-</mml:mo><mml:mi>δ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mspace linebreak="newline"/><mml:mo indentalign="id" indenttarget="d74a1">≥</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>sin</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>sin</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>δ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(74)</label></disp-formula>If <inline-formula><mml:math display="inline"><mml:mi>δ</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi>ϕ</mml:mi></mml:math></inline-formula> are small, this condition becomes, to leading order in small quantities, <disp-formula id="d75"><mml:math display="block"><mml:mrow><mml:mi>δ</mml:mi><mml:mo>≤</mml:mo><mml:msup><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">/</mml:mo><mml:mn>16</mml:mn><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(75)</label></disp-formula>Thus, when <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> is small, <inline-formula><mml:math display="inline"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>∼</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>H</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is far larger; the erasure is not locally correctable. The same will be true, even more so, for a positively curved bulk geometry.</p>
        <p>The failure of local correctability for holographic codes associated with flat and positively curved bulk manifolds suggests that, in these cases, the physics of the boundary system is highly nonlocal; in particular, the boundary state is not likely to be the ground state of a local Hamiltonian. This conclusion is reinforced by the observation that, according to the Ryu-Takayanagi formula, the entanglement entropy of a small connected region on the boundary of a flat ball scales linearly with the boundary volume of the region; this strong violation of the entanglement area law would not be expected in the ground state if the Hamiltonian is local.</p>
        <p>That flat bulk geometry implies nonlocal boundary physics also teaches us a valuable lesson about <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula>. A holographic tensor network provides not just an isometric map from the logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> to the physical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> of the manifold <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, but also a map from <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> to the boundary <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>X</mml:mi></mml:math></inline-formula> of a bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> that contains <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>. If the bulk geometry of <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> is flat or nearly flat, the entanglement structure of holographic codes indicates that the system supported on <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>X</mml:mi></mml:math></inline-formula> should exhibit flagrant violations of bulk locality. This picture suggests that black holes in the bulk that are small compared to the AdS curvature scale ought to have highly nonlocal dynamics, as seems necessary for these small black holes to be fast scramblers of quantum information <xref ref-type="bibr" rid="c37 c38">[37,38]</xref>.</p>
      </sec>
      <sec id="s5c">
        <label>C.</label>
        <title>Positively curved bulk</title>
        <p>This nonlocality of boundary physics is even more pronounced for holographic codes defined on positively curved manifolds. Consider the extreme case of a two-dimensional hemisphere <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>, with the boundary <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula> at its equator. Geodesics on the sphere are great circles, lying in a plane that passes through the sphere’s center. For any boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> with <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>≠</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>, there is a unique minimal surface <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula>, which lies in <inline-formula><mml:math display="inline"><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>; for <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>&lt;</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>, we have <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula>, while for <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>, we have <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula>. Invoking the Ryu-Takayanagi formula, we see that as <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> increases in size, the entropy <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> rises linearly as <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> until <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> occupies half of the boundary; it then decreases linearly thereafter. This behavior is the same as for a Haar-random pure state <xref ref-type="bibr" rid="c39">[39]</xref>.</p>
        <p>For <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>&lt;</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>, the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> contains only <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula>, while for <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>, we have <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi><mml:mo>⊔</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi></mml:math></inline-formula>, and the entanglement wedge <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> is all of the hemisphere <inline-formula><mml:math display="inline"><mml:mi>B</mml:mi></mml:math></inline-formula>. Accordingly, for any region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> in the bulk with associated bulk logical algebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>, the price <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> and distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> are both given by <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>. This also mimics the behavior of a Haar-random pure state.</p>
        <p>If we regulate bulk and boundary by introducing a lattice spacing <inline-formula><mml:math display="inline"><mml:mi>a</mml:mi></mml:math></inline-formula>, then the number <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> of boundary sites in the code block is <disp-formula id="d76"><mml:math display="block"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∂</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo></mml:math><label>(76)</label></disp-formula>where <inline-formula><mml:math display="inline"><mml:mi>r</mml:mi></mml:math></inline-formula> is the radius of the sphere. It is noteworthy that the area of the hemisphere, expressed in lattice units, is <disp-formula id="d77"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:msup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">/</mml:mo><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(77)</label></disp-formula>which is quadratic in <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula>. Since the hemisphere is the surface of smallest area whose boundary reproduces the entanglement structure of a Haar-random state, it is tempting to interpret the area <inline-formula><mml:math display="inline"><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:math></inline-formula> as a measure of the circuit complexity of preparing this state, in accordance with the complexity-equals-action conjecture <xref ref-type="bibr" rid="c40">[40]</xref>. Indeed, a random geometrically local circuit in the bulk containing <inline-formula><mml:math display="inline"><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> gates can closely approximate a unitary 2-design, which prepares a state with the desired properties <xref ref-type="bibr" rid="c41">[41]</xref>.</p>
        <p>As noted in Sec. <xref ref-type="sec" rid="s3b">III B</xref>, we can crudely model a black hole in the bulk by punching a hole in the bulk, with the microstates of the black hole residing on the logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> of the puncture. If we introduce a reference system that is maximally entangled with <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, then the black hole microstates are maximally mixed, and the entanglement entropy <inline-formula><mml:math display="inline"><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> counts these microstates, in agreement with the black hole’s Bekenstein-Hawking entropy. Alternatively, we might wish to describe a black hole in a typical pure state, rather than a highly mixed state. Our observations about the properties of a holographic code defined on a hemisphere suggest how this can be done. Instead of entangling its boundary with a reference system, we fill the puncture with a hemispherical cap. The tensor network filling this cap realizes the minimal geometrically local procedure for preparing the black hole’s highly scrambled pure state.</p>
      </sec>
    </sec>
    <sec id="s6">
      <label>VI.</label>
      <title>HOLOGRAPHIC STRONG QUANTUM SINGLETON BOUND</title>
      <p>In Sec. <xref ref-type="sec" rid="s2d">II D</xref>, we discussed the strong quantum Singleton bound, Corollary 1, which relates <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> for a code subspace, and we left open whether this bound can be extended to more general logical operator algebras. Here, we will see that, for holographic codes, such an extension is possible.</p>
      <p>We consider the case of a holographic code with punctures in the bulk; hence, there is a physical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> and a logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> as discussed in Sec. <xref ref-type="sec" rid="s3b">III B</xref>. In the formal continuum limit, the code parameters <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> are measured in units of area, and the contribution to the area from O(1) boundary sites can be neglected; hence, Eq. <xref ref-type="disp-formula" rid="d38">(38)</xref> becomes <disp-formula id="d78"><mml:math display="block"><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo>.</mml:mo></mml:math><label>(78)</label></disp-formula>We would like to show that this constraint applies to logical subalgebras of a holographic code.</p>
      <p>We consider a region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> in the bulk, and its associated logical subalgebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>. The region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> may contain a portion of the logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, as well as some additional isolated points in the bulk. We denote the intersection <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi><mml:mo>∩</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula> of <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> with the logical boundary by <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>; if <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> is nonempty, then the bulk points are a negligible portion of the subalgebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>, whose size is therefore <disp-formula id="d79"><mml:math display="block"><mml:msub><mml:mi>k</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:math><label>(79)</label></disp-formula></p>
      <p>In what follows, for the sake of clarity, we denote the minimal surface associated with boundary region <inline-formula><mml:math display="inline"><mml:mi>R</mml:mi></mml:math></inline-formula> by <inline-formula><mml:math display="inline"><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, in place of the subscript notation <inline-formula><mml:math display="inline"><mml:msub><mml:mi>χ</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></inline-formula> used earlier. We also use the notation <inline-formula><mml:math display="inline"><mml:msup><mml:mi>R</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:math></inline-formula> for the physical complement <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>\</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> as a shorthand for <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, <inline-formula><mml:math display="inline"><mml:msub><mml:mi>k</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>.</p>
      <p>Let <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> be a region of the physical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Φ</mml:mi></mml:math></inline-formula> such that <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>; this means that the associated minimal surface <inline-formula><mml:math display="inline"><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> must contain <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>. Let <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> be a subset of <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> such that, in the regulated theory with a nonzero lattice spacing, <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula> contains one less boundary site than the distance of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>; therefore, <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula> is surely correctable with respect to <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>, and in the continuum limit (where a single site has negligible size), <inline-formula><mml:math display="inline"><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mspace linebreak="goodbreak"/><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>. Because <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula> is correctable, the entanglement wedge of its physical complement <inline-formula><mml:math display="inline"><mml:msubsup><mml:mi>R</mml:mi><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, which means that <inline-formula><mml:math display="inline"><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>.</p>
      <p>We may consider gradually “growing” a boundary region from <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula> to <inline-formula><mml:math display="inline"><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula>, obtaining an inequality by observing that the corresponding minimal surface cannot grow faster than the boundary surface itself: <disp-formula id="und1"><mml:math display="block"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo indentalign="id" indenttarget="und1a1">≥</mml:mo><mml:msubsup><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mi>d</mml:mi><mml:mi>R</mml:mi><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo><mml:mspace linebreak="newline"/><mml:mo stretchy="false">|</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">|</mml:mo><mml:mo indentalign="id" indenttarget="und1a1">≥</mml:mo><mml:msubsup><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msubsup><mml:mi>d</mml:mi><mml:mi>R</mml:mi><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>Together with <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mi>p</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>, this implies <disp-formula id="d80"><mml:math display="block"><mml:mrow><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(80)</label></disp-formula></p>
      <p>Now recall that <inline-formula><mml:math display="inline"><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>. Hence, the rest of the minimal surface <inline-formula><mml:math display="inline"><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, excluding <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>, is <inline-formula><mml:math display="inline"><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, or in other words, <disp-formula id="d81"><mml:math display="block"><mml:mrow><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo indentalign="id" indenttarget="d81a1">=</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mspace linebreak="newline"/><mml:mo>⇒</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo indentalign="id" indenttarget="d81a1">=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(81)</label></disp-formula>Likewise, <inline-formula><mml:math display="inline"><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> contains <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula>, which implies <disp-formula id="d82"><mml:math display="block"><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo>∪</mml:mo><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:math><label>(82)</label></disp-formula>Plugging this into Eq. <xref ref-type="disp-formula" rid="d80">(80)</xref> yields <disp-formula id="d83"><mml:math display="block"><mml:mrow><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo indentalign="id" indenttarget="d83a1">=</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mspace linebreak="goodbreak"/><mml:mo indentalign="id" indenttarget="d83a1">≥</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mrow other="silent"><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mspace linebreak="goodbreak"/><mml:mo indentalign="id" indentshift="1em" indenttarget="d83a1">-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(83)</label></disp-formula></p>
      <p>Now we can use the property that two complementary boundary regions share the same minimal bulk surface (where by the “complement” we mean the boundary complement rather than the physical complement; that is, we are simultaneously taking the complement with respect to the logical and physical boundaries). Let us denote by <inline-formula><mml:math display="inline"><mml:msubsup><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:math></inline-formula> the complement of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="normal">Λ</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> with respect to the logical boundary so that <inline-formula><mml:math display="inline"><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. Then, <disp-formula id="d84"><mml:math display="block"><mml:mrow><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(84)</label></disp-formula><disp-formula id="d85"><mml:math display="block"><mml:mrow><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(85)</label></disp-formula>and hence, <disp-formula id="d86"><mml:math display="block"><mml:mrow><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mo indentalign="id" indenttarget="d86a1">≥</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mspace linebreak="newline"/><mml:mo indentalign="id" indentshift="1em" indenttarget="d86a1">-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(86)</label></disp-formula>Using the Ryu-Takayanagi relation between entropy and area, and identifying <disp-formula id="und2"><mml:math display="block"><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mo indentalign="id" indenttarget="und2a1">=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mspace linebreak="newline"/><mml:mi>B</mml:mi><mml:mo indentalign="id" indenttarget="und2a1">=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>the right-hand side of Eq. <xref ref-type="disp-formula" rid="d86">(86)</xref> is proportional to <disp-formula id="d87"><mml:math display="block"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(87)</label></disp-formula>which is non-negative by strong subadditivity of entropy. This completes the holographic proof of the strong quantum Singleton bound. <statement content-type="Theorem" id="st23"><label><bold>Theorem 3</bold> </label><p>(holographic strong quantum Singleton bound). Consider a holographic code with logical boundary <inline-formula><mml:math display="inline"><mml:mi mathvariant="normal">Λ</mml:mi></mml:math></inline-formula>, and a logical subalgebra <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> associated with bulk region <inline-formula><mml:math display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math display="inline"><mml:msub><mml:mi>k</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>X</mml:mi><mml:mo>∩</mml:mo><mml:mi mathvariant="normal">Λ</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>. Then, the price and distance of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:math></inline-formula> obey <disp-formula id="d88"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">A</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(88)</label></disp-formula></p></statement></p>
      <p>It is intriguing that we used strong subadditivity of entropy in this holographic proof, which applies to logical subalgebras, while the proof of Corollary 1, which applies to the price and distance of a traditional code subspace, used only subadditivity. We have not found a proof of the strong quantum Singleton bound that applies to logical subalgebras and that does not use holographic reasoning; it is an open question whether Eq. <xref ref-type="disp-formula" rid="d88">(88)</xref> holds beyond the setting of holographic codes.</p>
    </sec>
    <sec id="s7">
      <label>VII.</label>
      <title>DISCUSSION AND OUTLOOK</title>
      <p>Our studies of holographic codes have only scratched the surface of this subject. More in-depth studies are needed, including searches, guided by geometrical intuition, for codes with improved parameters and investigations of the efficiency of decoding.</p>
      <p>Regarding the implications of holographic codes for quantum gravity, we have uncovered several hints that may help steer future research. We have seen that positive curvature of the bulk manifold can improve properties such as the code distance but at a cost—increasing distance is accompanied by enhanced nonlocality of the boundary system. The observation that the logical algebra of a bulk point has price equal to distance is a step toward characterizing bulk geometry using algebraic ideas, and we anticipate further advances in that direction. Uberholography, in bulk spacetimes with asymptotically negative curvature, illustrates how notions from quantum coding can elucidate the emergence of bulk geometry beyond the appearance of just one extra spatial dimension.</p>
      <p>Following Refs. <xref ref-type="bibr" rid="c1 c10">[1,10]</xref>, we have discussed boundary reconstruction of bulk physics using the formalism of OAQEC <xref ref-type="bibr" rid="c5 c6">[5,6]</xref>, which captures salient features of holography. To make firmer contact with realistic <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula>, this discussion should be extended to the setting of approximate OAQEC <xref ref-type="bibr" rid="c42">[42]</xref>. First steps in this direction have already been taken in Ref. <xref ref-type="bibr" rid="c31">[31]</xref>, a study of approximate erasure correction in the (<inline-formula><mml:math display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>)-dimensional Ising CFT at very low temperatures, and in Ref. <xref ref-type="bibr" rid="c32">[32]</xref>, an investigation of approximate <italic>local</italic> correctability in a MERA network, which has polynomially decaying correlations on its boundary.</p>
      <p>We are encouraged by recent progress connecting quantum error correction and quantum gravity, but much remains unclear. Most obviously, our discussion of the entanglement wedge and bulk reconstruction applies only to static spacetimes or very special spatial slices through dynamical spacetimes. Applying the principles of quantum coding to more general dynamical spacetimes is an important goal, which poses serious unresolved challenges.</p>
    </sec>
  </body>
  <back>
    <ack>
      <title>ACKNOWLEDGMENTS</title>
      <p>F. P. would like to thank Nicolas Delfosse, Henrik Wilming, and Jens Eisert for helpful discussions and comments. F. P. gratefully acknowledges funding provided by the Institute for Quantum Information and Matter, a NSF Physics Frontiers Center, with support from the Gordon and Betty Moore Foundation, as well as the Simons Foundation through the It from Qubit program and the FUB through the ERC project (TAQ). This research was supported in part by the National Science Foundation under Grant No. NSF PHY-1125915.</p>
    </ack>
    <app-group>
      <app id="app1">
        <label>APPENDIX:</label>
        <title>COMPARISON OF UBERHOLOGRAPHY DIMENSIONAL EXPONENT WITH EXPLICIT CODES</title>
        <p>In Sec. <xref ref-type="sec" rid="s4">IV</xref>, we computed the universal fractal dimension <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi><mml:mo>≈</mml:mo><mml:mn>0.786</mml:mn></mml:math></inline-formula> for a holographic code defined on the Poincaré disk, assuming that geometric complementarity and the entanglement wedge hypothesis are precisely satisfied. We may also define a fractal dimension for other code families, such as concatenated quantum codes or holographic tensor network codes. Choosing a particular logical algebra <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> (for example, the algebra of a logical qubit at the center of the bulk), let <disp-formula id="da1"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>≔</mml:mo><mml:munder><mml:mrow><mml:mi>lim</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo stretchy="false">→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mi>log</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>log</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>≔</mml:mo><mml:munder><mml:mrow><mml:mi>lim</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo stretchy="false">→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mi>log</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>log</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(A1)</label></disp-formula>where <inline-formula><mml:math display="inline"><mml:msub><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi>d</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula> are the price and distance of the logical algebra after <inline-formula><mml:math display="inline"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> levels of concatenation or equivalent iteration. (If <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the algebra of local operators at the center of the bulk, then we may think of <inline-formula><mml:math display="inline"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> as the radial distance from the center of the bulk to its boundary.) The “no free lunch” lemma ensures that <inline-formula><mml:math display="inline"><mml:msub><mml:mi>α</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula>.</p>
        <p>By a concatenated code, we mean a recursive hierarchy of codes within codes; these can be constructed in many ways. In the simplest case, we consider an <inline-formula><mml:math display="inline"><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula>, with just one logical qubit, which has an encoder isometrically mapping one qubit to a block of <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> physical qubits. The code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, which has <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> and length <inline-formula><mml:math display="inline"><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:math></inline-formula>, is obtained by applying this encoder to each of the <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> physical qubits in <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula>; likewise, the code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula>, with length <inline-formula><mml:math display="inline"><mml:msup><mml:mi>n</mml:mi><mml:mo>ℓ</mml:mo></mml:msup></mml:math></inline-formula>, is obtained by applying the encoder to each of the <inline-formula><mml:math display="inline"><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> qubits in the code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula>. The corresponding tensor network, with one logical qubit at its center, is a branching tree extending radially outward, in which each branch has <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> descendants.</p>
        <p>Suppose that <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> is odd and the code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> has the largest possible distance <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>. The complementarity bound Eq. <xref ref-type="disp-formula" rid="d25">(25)</xref> then implies that the price is <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>d</mml:mi></mml:math></inline-formula>; the full logical algebra can be supported on <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> of the <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> qubits, and all nontrivial logical Pauli operators have weight <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula>. Therefore, all nontrivial logical operators of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula> can be supported on <inline-formula><mml:math display="inline"><mml:msup><mml:mi>d</mml:mi><mml:mo>ℓ</mml:mo></mml:msup></mml:math></inline-formula> qubits, and all have weight <inline-formula><mml:math display="inline"><mml:msup><mml:mi>d</mml:mi><mml:mo>ℓ</mml:mo></mml:msup></mml:math></inline-formula>. We conclude that <disp-formula id="da2"><mml:math display="block"><mml:msub><mml:mi>α</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>log</mml:mi><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>log</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math><label>(A2)</label></disp-formula>As <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> increases, <inline-formula><mml:math display="inline"><mml:msub><mml:mi>α</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math display="inline"><mml:msub><mml:mi>α</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula> approach 1 from below. Although the tensor network can be embedded in a plane, it does not approximate the geometry of the Poincaré disk, and its price and distance obey a different scaling law than we found in Sec. <xref ref-type="sec" rid="s4">IV</xref>.</p>
        <p>A more complicated recursive encoding scheme, based on an <inline-formula><mml:math display="inline"><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula> code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> with <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>, is depicted in Fig. <xref ref-type="fig" rid="f6">6</xref>. In this case, the <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> encoder maps <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> qubits to a block of <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula> qubits. To build the code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula>, we first assemble <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> copies of the code <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula>, and then apply the <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>n</mml:mi></mml:math></inline-formula> encoder for <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> altogether <inline-formula><mml:math display="inline"><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> times, where each encoder acts on <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> qubits drawn from the <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> distinct copies. Each time we add another layer to the code, the number of encoded qubits increases by a factor of <inline-formula><mml:math display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>, and the number of physical qubits increases by a factor of <inline-formula><mml:math display="inline"><mml:mi>n</mml:mi></mml:math></inline-formula>; therefore, <disp-formula id="da3"><mml:math display="block"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace depth="0.0ex" height="0.0ex" width="2em"/><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(A3)</label></disp-formula>However, in this case, the price and distance of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula> are not so easy to calculate, though we can derive some simple bounds. When we add an additional layer to the code, each nontrivial logical operator of <inline-formula><mml:math display="inline"><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> maps to a logical operator of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula> whose weight is at least <inline-formula><mml:math display="inline"><mml:mi>d</mml:mi></mml:math></inline-formula> times larger; furthermore, if all logical operators of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> can be supported on <inline-formula><mml:math display="inline"><mml:mi>w</mml:mi></mml:math></inline-formula> physical qubits, then at most <inline-formula><mml:math display="inline"><mml:mi>p</mml:mi><mml:mi>w</mml:mi></mml:math></inline-formula> qubits are needed to support all logical operators of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula>. We therefore have <disp-formula id="da4"><mml:math display="block"><mml:mrow><mml:msup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>ℓ</mml:mo></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math><label>(A4)</label></disp-formula>However, to make a more precise statement about the price and distance of <inline-formula><mml:math display="inline"><mml:msub><mml:mi>C</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula>, we need more information about the structure of <inline-formula><mml:math display="inline"><mml:msub><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula>.</p>
        <fig id="f6">
          <object-id>6</object-id>
          <object-id pub-id-type="doi">10.1103/PhysRevX.7.021022.f6</object-id>
          <label>FIG. 6.</label>
          <caption>
            <p>A recursive coding network to which Eqs. <xref ref-type="disp-formula" rid="da3">(A3)</xref> and <xref ref-type="disp-formula" rid="da4">(A4)</xref> apply, with logical qubits at the top and physical qubits at the bottom. To derive that the distance is bounded below by <inline-formula><mml:math display="inline"><mml:msup><mml:mi>d</mml:mi><mml:mo>ℓ</mml:mo></mml:msup></mml:math></inline-formula> and the price is bounded above by <inline-formula><mml:math display="inline"><mml:msup><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msup></mml:math></inline-formula>, it suffices to observe that there is a unique “causal” path connecting each physical qubit to each logical qubit. Here, a [[4,2,2]] code (with the encoder drawn as a parallelogram) is concatenated to obtain a [[16,4,4]] code, and a causal path connecting a physical qubit to a logical qubit is highlighted.</p>
          </caption>
          <graphic xlink:href="e021022_6.eps"/>
        </fig>
        <p>We may also consider the price and distance of holographic tensor network codes, which capture some of the features of full-blown <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>AdS</mml:mi><mml:mo>/</mml:mo><mml:mi>CFT</mml:mi></mml:mrow></mml:math></inline-formula> duality <xref ref-type="bibr" rid="c2">[2]</xref>. For example, we can tile the Poincaré disk with pentagons and associate a six-index “perfect tensor” with each pentagon, where each pentagon carries a single logical qubit. For this pentagon code, where <inline-formula><mml:math display="inline"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> is the logical algebra of the central pentagon, we find that the price <inline-formula><mml:math display="inline"><mml:msub><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> and distance <inline-formula><mml:math display="inline"><mml:msub><mml:mi>d</mml:mi><mml:mo>ℓ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> are badly mismatched (where <inline-formula><mml:math display="inline"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> denotes the graph distance from the central pentagon to the physical boundary of the tensor network). In fact, the distance <inline-formula><mml:math display="inline"><mml:msub><mml:mi>d</mml:mi><mml:mo>ℓ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math></inline-formula> is a constant independent of <inline-formula><mml:math display="inline"><mml:mo>ℓ</mml:mo></mml:math></inline-formula>, as explained in Sec. 5.6 of Ref. <xref ref-type="bibr" rid="c2">[2]</xref>; in other words, there are logical operators of weight 4 that act nontrivially on the central qubit. In contrast, we expect the price to scale as <inline-formula><mml:math display="inline"><mml:msub><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mo>ℓ</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>5</mml:mn></mml:mrow></mml:msub></mml:msubsup></mml:math></inline-formula> with <inline-formula><mml:math display="inline"><mml:mn>0.786</mml:mn><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>5</mml:mn></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> (i.e., with an exponent larger than the value attained in idealized holography). This upper bound may be derived using a discrete version of the hole-punching approach, thereby explicitly constructing a subset of the physical boundary qubits for which the greedy algorithm of Ref. <xref ref-type="bibr" rid="c2">[2]</xref> reaches the central tensor. It is more difficult to obtain lower bounds on <inline-formula><mml:math display="inline"><mml:msub><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:math></inline-formula>, as these cannot be witnessed by examples.</p>
        <p>A nontrivial scaling exponent for the distance <inline-formula><mml:math display="inline"><mml:msub><mml:mi>d</mml:mi><mml:mo>ℓ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> can be obtained if we thin out the logical qubits, replacing pentagons in the bulk by hexagons that carry no logical qubit index. (In such codes, the central qubit is well protected against erasure of a randomly chosen nonzero fraction of all the physical boundary qubits, as shown in Ref. <xref ref-type="bibr" rid="c2">[2]</xref>.) Codes with relatively sparse bulk logical qubits are better suited than the pentagon code for illustrating the ideas we have explored in this paper, where we have focused on the regime in which geometric entanglement dominates bulk entanglement. We may anticipate that holographic tensor network code families that mimic the geometry of the Poincaré disk will have a price-scaling exponent <inline-formula><mml:math display="inline"><mml:msub><mml:mi>α</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> that approximates <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi><mml:mo>≈</mml:mo><mml:mn>0.786</mml:mn></mml:math></inline-formula> from above and a distance-scaling exponent <inline-formula><mml:math display="inline"><mml:msub><mml:mi>α</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula> that approximates <inline-formula><mml:math display="inline"><mml:mi>α</mml:mi></mml:math></inline-formula> from below. We have confirmed this expectation by studying some examples, though we have no rigorous general argument.</p>
      </app>
    </app-group>
    <ref-list>
      <ref id="c1">
        <label>[1]</label>
        <mixed-citation publication-type="journal"><object-id>1</object-id><person-group person-group-type="author"><string-name>A. Almheiri</string-name>, <string-name>X. Dong</string-name>, and <string-name>D. Harlow</string-name></person-group>, <article-title>Bulk Locality and Quantum Error Correction in AdS/CFT</article-title>, <source>J. High Energy Phys.</source><issue>04</issue> (<volume>2015</volume>) <page-range>163</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP04(2015)163</pub-id></mixed-citation>
      </ref>
      <ref id="c2">
        <label>[2]</label>
        <mixed-citation publication-type="journal"><object-id>2</object-id><person-group person-group-type="author"><string-name>F. Pastawski</string-name>, <string-name>B. Yoshida</string-name>, <string-name>D. Harlow</string-name>, and <string-name>J. Preskill</string-name></person-group>, <article-title>Holographic Quantum Error-Correcting Codes: Toy Models for the Bulk/Boundary Correspondence</article-title>, <source>J. High Energy Phys.</source><issue>06</issue> (<volume>2015</volume>) <page-range>149</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP06(2015)149</pub-id></mixed-citation>
      </ref>
      <ref id="c3">
        <label>[3]</label>
        <mixed-citation publication-type="journal"><object-id>3</object-id><person-group person-group-type="author"><string-name>P. Hayden</string-name>, <string-name>S. Nezami</string-name>, <string-name>X.-L. Qi</string-name>, <string-name>N. Thomas</string-name>, <string-name>M. Walter</string-name>, and <string-name>Z. Yang</string-name></person-group>, <article-title>Holographic Duality from Random Tensor Networks</article-title>, <source>J. High Energy Phys.</source><issue>11</issue> (<volume>2016</volume>) <page-range>009</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP11(2016)009</pub-id></mixed-citation>
      </ref>
      <ref id="c4">
        <label>[4]</label>
        <mixed-citation publication-type="journal"><object-id>4</object-id><person-group person-group-type="author"><string-name>D. W. Kribs</string-name>, <string-name>R. Laflamme</string-name>, and <string-name>D. Poulin</string-name></person-group>, <article-title>Unified and Generalized Approach to Quantum Error Correction</article-title>, <source>Phys. Rev. Lett.</source><volume>94</volume>, <page-range>180501</page-range> (<year>2005</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.94.180501</pub-id></mixed-citation>
      </ref>
      <ref id="c5">
        <label>[5]</label>
        <mixed-citation publication-type="journal"><object-id>5</object-id><person-group person-group-type="author"><string-name>C. Bény</string-name>, <string-name>A. Kempf</string-name>, and <string-name>D. W. Kribs</string-name></person-group>, <article-title>Quantum Error Correction of Observables</article-title>, <source>Phys. Rev. A</source><volume>76</volume>, <page-range>042303</page-range> (<year>2007</year>).<pub-id pub-id-type="coden">PLRAAN</pub-id><issn>1050-2947</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevA.76.042303</pub-id></mixed-citation>
      </ref>
      <ref id="c6">
        <label>[6]</label>
        <mixed-citation publication-type="journal"><object-id>6</object-id><person-group person-group-type="author"><string-name>C. Bény</string-name>, <string-name>A. Kempf</string-name>, and <string-name>D. W. Kribs</string-name></person-group>, <article-title>Generalization of Quantum Error Correction via the Heisenberg Picture</article-title>, <source>Phys. Rev. Lett.</source><volume>98</volume>, <page-range>100502</page-range> (<year>2007</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.98.100502</pub-id></mixed-citation>
      </ref>
      <ref id="c7">
        <label>[7]</label>
        <mixed-citation publication-type="journal"><object-id>7</object-id><person-group person-group-type="author"><string-name>M. A. Nielsen</string-name> and <string-name>D. Poulin</string-name></person-group>, <article-title>Algebraic and Information-Theoretic Conditions for Operator Quantum Error Correction</article-title>, <source>Phys. Rev. A</source><volume>75</volume>, <page-range>064304</page-range> (<year>2007</year>).<pub-id pub-id-type="coden">PLRAAN</pub-id><issn>1050-2947</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevA.75.064304</pub-id></mixed-citation>
      </ref>
      <ref id="c8">
        <label>[8]</label>
        <mixed-citation publication-type="eprint"><object-id>8</object-id><person-group person-group-type="author"><string-name>W. Donnelly</string-name>, <string-name>B. Michel</string-name>, <string-name>D. Marolf</string-name>, and <string-name>J. Wien</string-name></person-group>, <article-title>Living on the Edge: A Toy Model for Holographic Reconstruction of Algebras with Centers</article-title>, <pub-id pub-id-type="arxiv">arXiv:1611.05841</pub-id>.</mixed-citation>
      </ref>
      <ref id="c9">
        <label>[9]</label>
        <mixed-citation publication-type="journal"><object-id>9</object-id><person-group person-group-type="author"><string-name>A. Almheiri</string-name>, <string-name>X. Dong</string-name>, and <string-name>B. Swingle</string-name></person-group>, <article-title>Linearity of Holographic Entanglement Entropy</article-title>, <source>J. High Energy Phys.</source><issue>02</issue> (<volume>2017</volume>) <page-range>074</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP02(2017)074</pub-id></mixed-citation>
      </ref>
      <ref id="c10">
        <label>[10]</label>
        <mixed-citation publication-type="eprint"><object-id>10</object-id><person-group person-group-type="author"><string-name>D. Harlow</string-name></person-group>, <article-title>The Ryu-Takayanagi Formula from Quantum Error Correction</article-title>, <pub-id pub-id-type="arxiv">arXiv:1607.03901</pub-id>.</mixed-citation>
      </ref>
      <ref id="c11">
        <label>[11]</label>
        <mixed-citation publication-type="journal"><object-id>11</object-id><person-group person-group-type="author"><string-name>D. Poulin</string-name></person-group>, <article-title>Stabilizer Formalism for Operator Quantum Error Correction</article-title>, <source>Phys. Rev. Lett.</source><volume>95</volume>, <page-range>230504</page-range> (<year>2005</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.95.230504</pub-id></mixed-citation>
      </ref>
      <ref id="c12">
        <label>[12]</label>
        <mixed-citation publication-type="journal"><object-id>12</object-id><person-group person-group-type="author"><string-name>D. W. Kribs</string-name>, <string-name>R. Laflamme</string-name>, <string-name>D. Poulin</string-name>, and <string-name>M. Lesosky</string-name></person-group>, <article-title>Operator Quantum Error Correction</article-title>, <source>Quantum Inf. Comput.</source><volume>6</volume>, <page-range>382</page-range> (<year>2006</year>).<pub-id pub-id-type="coden">QICUAW</pub-id><issn>1533-7146</issn></mixed-citation>
      </ref>
      <ref id="c13">
        <label>[13]</label>
        <mixed-citation publication-type="journal"><object-id>13</object-id><person-group person-group-type="author"><string-name>E. Knill</string-name> and <string-name>R. Laflamme</string-name></person-group>, <article-title>Theory of Quantum Error-Correcting Codes</article-title>, <source>Phys. Rev. A</source><volume>55</volume>, <page-range>900</page-range> (<year>1997</year>).<pub-id pub-id-type="coden">PLRAAN</pub-id><issn>1050-2947</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevA.55.900</pub-id></mixed-citation>
      </ref>
      <ref id="c14">
        <label>[14]</label>
        <mixed-citation publication-type="journal"><object-id>14</object-id><person-group person-group-type="author"><string-name>J. M. Maldacena</string-name></person-group>, <article-title>The Large <inline-formula><mml:math display="inline"><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> Limit of Superconformal Field Theories and Supergravity</article-title>, <source>Adv. Theor. Math. Phys.</source><volume>2</volume>, <page-range>231</page-range> (<year>1998</year>).<issn>1095-0761</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.4310/ATMP.1998.v2.n2.a1</pub-id></mixed-citation>
      </ref>
      <ref id="c15">
        <label>[15]</label>
        <mixed-citation publication-type="journal"><object-id>15</object-id><person-group person-group-type="author"><string-name>S. Ryu</string-name> and <string-name>T. Takayanagi</string-name></person-group>, <article-title>Holographic Derivation of Entanglement Entropy from the Anti–de Sitter Space/Conformal Field Theory Correspondence</article-title>, <source>Phys. Rev. Lett.</source><volume>96</volume>, <page-range>181602</page-range> (<year>2006</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.96.181602</pub-id></mixed-citation>
      </ref>
      <ref id="c16">
        <label>[16]</label>
        <mixed-citation publication-type="journal"><object-id>16</object-id><person-group person-group-type="author"><string-name>M. Van Raamsdonk</string-name></person-group>, <article-title>Building up Spacetime with Quantum Entanglement</article-title>, <source>Gen. Relativ. Gravit.</source><volume>42</volume>, <page-range>2323</page-range> (<year>2010</year>).<pub-id pub-id-type="coden">GRGVA8</pub-id><issn>0001-7701</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/s10714-010-1034-0</pub-id></mixed-citation>
      </ref>
      <ref id="c17">
        <label>[17]</label>
        <mixed-citation publication-type="journal"><object-id>17</object-id><person-group person-group-type="author"><string-name>V. E. Hubeny</string-name>, <string-name>M. Rangamani</string-name>, and <string-name>T. Takayanagi</string-name></person-group>, <article-title>A Covariant Holographic Entanglement Entropy Proposal</article-title>, <source>J. High Energy Phys.</source><issue>07</issue> (<volume>2007</volume>) <page-range>062</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1088/1126-6708/2007/07/062</pub-id></mixed-citation>
      </ref>
      <ref id="c18">
        <label>[18]</label>
        <mixed-citation publication-type="journal"><object-id>18</object-id><person-group person-group-type="author"><string-name>B. Czech</string-name>, <string-name>J. L. Karczmarek</string-name>, <string-name>F. Nogueira</string-name>, and <string-name>M. Van Raamsdonk</string-name></person-group>, <article-title>The Gravity Dual of a Density Matrix</article-title>, <source>Classical Quantum Gravity</source><volume>29</volume>, <page-range>155009</page-range> (<year>2012</year>).<pub-id pub-id-type="coden">CQGRDG</pub-id><issn>0264-9381</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1088/0264-9381/29/15/155009</pub-id></mixed-citation>
      </ref>
      <ref id="c19">
        <label>[19]</label>
        <mixed-citation publication-type="journal"><object-id>19</object-id><person-group person-group-type="author"><string-name>D. L. Jafferis</string-name> and <string-name>S. J. Suh</string-name></person-group>, <article-title>The Gravity Duals of Modular Hamiltonians</article-title>, <source>J. High Energy Phys.</source><issue>09</issue> (<volume>2016</volume>) <page-range>068</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP09(2016)068</pub-id></mixed-citation>
      </ref>
      <ref id="c20">
        <label>[20]</label>
        <mixed-citation publication-type="journal"><object-id>20</object-id><person-group person-group-type="author"><string-name>A. Wall</string-name></person-group>, <article-title>Maximin Surfaces, and the Strong Subadditivity of the Covariant Holographic Entanglement Entropy</article-title>, <source>Classical Quantum Gravity</source><volume>31</volume>, <page-range>225007</page-range> (<year>2014</year>).<pub-id pub-id-type="coden">CQGRDG</pub-id><issn>0264-9381</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1088/0264-9381/31/22/225007</pub-id></mixed-citation>
      </ref>
      <ref id="c21">
        <label>[21]</label>
        <mixed-citation publication-type="journal"><object-id>21</object-id><person-group person-group-type="author"><string-name>X. Dong</string-name>, <string-name>D. Harlow</string-name>, and <string-name>A. C. Wall</string-name></person-group>, <article-title>Reconstruction of Bulk Operators within the Entanglement Wedge in Gauge-Gravity Duality</article-title>, <source>Phys. Rev. Lett.</source><volume>117</volume>, <page-range>021601</page-range> (<year>2016</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.117.021601</pub-id></mixed-citation>
      </ref>
      <ref id="c22">
        <label>[22]</label>
        <mixed-citation publication-type="eprint"><object-id>22</object-id><person-group person-group-type="author"><string-name>N. Bao</string-name> and <string-name>I. H. Kim</string-name></person-group>, <article-title>Precursor Problem and Holographic Mutual Information</article-title>, <pub-id pub-id-type="arxiv">arXiv:hep-th/1601.07616</pub-id>.</mixed-citation>
      </ref>
      <ref id="c23">
        <label>[23]</label>
        <mixed-citation publication-type="journal"><object-id>23</object-id><person-group person-group-type="author"><string-name>R. Bousso</string-name></person-group>, <article-title>A Covariant Entropy Conjecture</article-title>, <source>J. High Energy Phys.</source><issue>07</issue> (<volume>1999</volume>) <page-range>004</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1088/1126-6708/1999/07/004</pub-id></mixed-citation>
      </ref>
      <ref id="c24">
        <label>[24]</label>
        <mixed-citation publication-type="journal"><object-id>24</object-id><person-group person-group-type="author"><string-name>J. Maldacena</string-name></person-group>, <article-title>Eternal Black Holes in Anti–de Sitter</article-title>, <source>J. High Energy Phys.</source><issue>04</issue> (<volume>2003</volume>) <page-range>021</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1088/1126-6708/2003/04/021</pub-id></mixed-citation>
      </ref>
      <ref id="c25">
        <label>[25]</label>
        <mixed-citation publication-type="journal"><object-id>25</object-id><person-group person-group-type="author"><string-name>T. Faulkner</string-name>, <string-name>A. Lewkowycz</string-name>, and <string-name>J. Maldacena</string-name></person-group>, <article-title>Quantum Corrections to Holographic Entanglement Entropy</article-title>, <source>J. High Energy Phys.</source><issue>11</issue> (<volume>2013</volume>) <page-range>074</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP11(2013)074</pub-id></mixed-citation>
      </ref>
      <ref id="c26">
        <label>[26]</label>
        <mixed-citation publication-type="journal"><object-id>26</object-id><person-group person-group-type="author"><string-name>J. Maldacena</string-name> and <string-name>L. Susskind</string-name></person-group>, <article-title>Cool Horizons for Entangled Black Holes</article-title>, <source>Fortschr. Phys.</source><volume>61</volume>, <page-range>781</page-range> (<year>2013</year>).<pub-id pub-id-type="coden">FPYKA6</pub-id><issn>0015-8208</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1002/prop.201300020</pub-id></mixed-citation>
      </ref>
      <ref id="c27">
        <label>[27]</label>
        <mixed-citation publication-type="journal"><object-id>27</object-id><person-group person-group-type="author"><string-name>S. Bravyi</string-name>, <string-name>D. Poulin</string-name>, and <string-name>B. Terhal</string-name></person-group>, <article-title>Tradeoffs for Reliable Quantum Information Storage in 2D Systems</article-title>, <source>Phys. Rev. Lett.</source><volume>104</volume>, <page-range>050503</page-range> (<year>2010</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.104.050503</pub-id></mixed-citation>
      </ref>
      <ref id="c28">
        <label>[28]</label>
        <mixed-citation publication-type="eprint"><object-id>28</object-id><person-group person-group-type="author"><string-name>S. T. Flammia</string-name>, <string-name>J. Haah</string-name>, <string-name>M. J. Kastoryano</string-name>, and <string-name>I. H. Kim</string-name></person-group>, <article-title>Limits on the Storage of Quantum Information in a Volume of Space</article-title>, <pub-id pub-id-type="arxiv">arXiv:1610.06169</pub-id>.</mixed-citation>
      </ref>
      <ref id="c29">
        <label>[29]</label>
        <mixed-citation publication-type="journal"><object-id>29</object-id><person-group person-group-type="author"><string-name>D. Petz</string-name></person-group>, <article-title>Sufficiency of Channels Over Von Neumann Algebras</article-title>, <source>Q. J. Math.</source><volume>39</volume>, <page-range>97</page-range> (<year>1988</year>).<pub-id pub-id-type="coden">QJMMAV</pub-id><issn>0033-5606</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1093/qmath/39.1.97</pub-id></mixed-citation>
      </ref>
      <ref id="c30">
        <label>[30]</label>
        <mixed-citation publication-type="journal"><object-id>30</object-id><person-group person-group-type="author"><string-name>O. Fawzi</string-name> and <string-name>R. Renner</string-name></person-group>, <article-title>Quantum Conditional Mutual Information and Approximate Markov Chains</article-title>, <source>Commun. Math. Phys.</source><volume>340</volume>, <page-range>575</page-range> (<year>2015</year>).<pub-id pub-id-type="coden">CMPHAY</pub-id><issn>0010-3616</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/s00220-015-2466-x</pub-id></mixed-citation>
      </ref>
      <ref id="c31">
        <label>[31]</label>
        <mixed-citation publication-type="eprint"><object-id>31</object-id><person-group person-group-type="author"><string-name>F. Pastawski</string-name>, <string-name>J. Eisert</string-name>, and <string-name>H. Wilming</string-name></person-group>, <article-title>Quantum Source-Channel Codes</article-title>, <pub-id pub-id-type="arxiv">arXiv:1611.07528</pub-id> [<source>Phys. Rev. Lett.</source> (to be published)].</mixed-citation>
      </ref>
      <ref id="c32">
        <label>[32]</label>
        <mixed-citation publication-type="journal"><object-id>32</object-id><person-group person-group-type="author"><string-name>I. H. Kim</string-name> and <string-name>M. J. Kastoryano</string-name></person-group>, <article-title>Entanglement Renormalization, Quantum Error Correction, and Bulk Causality</article-title>, <source>J. High Energy Phys.</source><issue>04</issue> (<volume>2017</volume>) <page-range>040</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/JHEP04(2017)040</pub-id></mixed-citation>
      </ref>
      <ref id="c33">
        <label>[33]</label>
        <mixed-citation publication-type="journal"><object-id>33</object-id><person-group person-group-type="author"><string-name>M. Headrick</string-name></person-group>, <article-title>Entanglement Rényi Entropies in Holographic Theories</article-title>, <source>Phys. Rev. D</source><volume>82</volume>, <page-range>126010</page-range> (<year>2010</year>).<pub-id pub-id-type="coden">PRVDAQ</pub-id><issn>1550-7998</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevD.82.126010</pub-id></mixed-citation>
      </ref>
      <ref id="c34">
        <label>[34]</label>
        <mixed-citation publication-type="journal"><object-id>34</object-id><person-group person-group-type="author"><string-name>X. Dong</string-name></person-group>, <article-title>The Gravity Dual of Rényi Entropy</article-title>, <source>Nat. Commun.</source><volume>7</volume>, <page-range>12472</page-range> (<year>2016</year>).<pub-id pub-id-type="coden">NCAOBW</pub-id><issn>2041-1723</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1038/ncomms12472</pub-id></mixed-citation>
      </ref>
      <ref id="c35">
        <label>[35]</label>
        <mixed-citation publication-type="journal"><object-id>35</object-id><person-group person-group-type="author"><string-name>X. Dong</string-name></person-group>, <article-title>Shape Dependence of Holographic Rényi Entropy in Conformal Field Theories</article-title>, <source>Phys. Rev. Lett.</source><volume>116</volume>, <page-range>251602</page-range> (<year>2016</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.116.251602</pub-id></mixed-citation>
      </ref>
      <ref id="c36">
        <label>[36]</label>
        <mixed-citation publication-type="journal"><object-id>36</object-id><person-group person-group-type="author"><string-name>D. Sutter</string-name>, <string-name>O. Fawzi</string-name>, and <string-name>R. Renner</string-name></person-group>, <article-title>Universal Recovery Map for Approximate Markov Chains</article-title>, <source>Proc. R. Soc. Lond A</source><volume>472</volume>, <page-range>623</page-range> (<year>2016</year>).<issn>1364-5021</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1098/rspa.2015.0623</pub-id></mixed-citation>
      </ref>
      <ref id="c37">
        <label>[37]</label>
        <mixed-citation publication-type="journal"><object-id>37</object-id><person-group person-group-type="author"><string-name>P. Hayden</string-name> and <string-name>J. Preskill</string-name></person-group>, <article-title>Black Holes as Mirrors: Quantum Information in Random Subsystems</article-title>, <source>J. High Energy Phys.</source><issue>09</issue> (<volume>2007</volume>) <page-range>120</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1088/1126-6708/2007/09/120</pub-id></mixed-citation>
      </ref>
      <ref id="c38">
        <label>[38]</label>
        <mixed-citation publication-type="journal"><object-id>38</object-id><person-group person-group-type="author"><string-name>Y. Sekino</string-name> and <string-name>L. Susskind</string-name></person-group>, <article-title>Fast Scramblers</article-title>, <source>J. High Energy Phys.</source><issue>10</issue> (<volume>2008</volume>) <page-range>065</page-range>.<pub-id pub-id-type="coden">JHEPFG</pub-id><issn>1029-8479</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1088/1126-6708/2008/10/065</pub-id></mixed-citation>
      </ref>
      <ref id="c39">
        <label>[39]</label>
        <mixed-citation publication-type="journal"><object-id>39</object-id><person-group person-group-type="author"><string-name>D. N. Page</string-name></person-group>, <article-title>Average Entropy of a Subsystem</article-title>, <source>Phys. Rev. Lett.</source><volume>71</volume>, <page-range>1291</page-range> (<year>1993</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.71.1291</pub-id></mixed-citation>
      </ref>
      <ref id="c40">
        <label>[40]</label>
        <mixed-citation publication-type="journal"><object-id>40</object-id><person-group person-group-type="author"><string-name>A. R. Brown</string-name>, <string-name>D. A. Roberts</string-name>, <string-name>L. Susskind</string-name>, <string-name>B. Swingle</string-name>, and <string-name>Y. Zhao</string-name></person-group>, <article-title>Holographic Complexity Equals Bulk Action?</article-title>, <source>Phys. Rev. Lett.</source><volume>116</volume>, <page-range>191301</page-range> (<year>2016</year>).<pub-id pub-id-type="coden">PRLTAO</pub-id><issn>0031-9007</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1103/PhysRevLett.116.191301</pub-id></mixed-citation>
      </ref>
      <ref id="c41">
        <label>[41]</label>
        <mixed-citation publication-type="journal"><object-id>41</object-id><person-group person-group-type="author"><string-name>F. G. S. L. Brandão</string-name>, <string-name>A. W. Harrow</string-name>, and <string-name>M. Horodecki</string-name></person-group>, <article-title>Local Random Quantum Circuits are Approximate Polynomial-Designs</article-title>, <source>Commun. Math. Phys.</source><volume>346</volume>, <page-range>397</page-range> (<year>2016</year>).<pub-id pub-id-type="coden">CMPHAY</pub-id><issn>0010-3616</issn><pub-id pub-id-type="doi" specific-use="suppress-display">10.1007/s00220-016-2706-8</pub-id></mixed-citation>
      </ref>
      <ref id="c42">
        <label>[42]</label>
        <mixed-citation publication-type="eprint"><object-id>42</object-id><person-group person-group-type="author"><string-name>C. Bény</string-name></person-group>, <article-title>Conditions for the Approximate Correction of Algebras</article-title>, <pub-id pub-id-type="arxiv">arXiv:0907.4207</pub-id>.</mixed-citation>
      </ref>
    </ref-list>
  </back>
</article>
